#!/usr/bin/env bash

if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
  cat <<EOF
Usage: $0 [-h|--help]
       $0 [--no-dry-run] [--prefix PREFIX]
EOF
  exit 0
fi

DRYRUN=yes
PREFIX=''

if [ "$1" = '--no-dry-run' ]; then
  DRYRUN=no
  shift
fi

if [ "$1" = '--prefix' ]; then
  shift
  if [ -n "$1" ]; then
    PREFIX="$1"
  fi
fi

if [ -z "${PREFIX}" ]; then
  if [ 'no' = "${DRYRUN}" ]; then
    PREFIX="${PREFIX:-${HOME}}"
  else
    PREFIX="$(mktemp -d)"
  fi
fi


if [ 'no' != "${DRYRUN}" ]; then
  echo "Dry-Run mode, install to: '${PREFIX}'"
else
  echo "Install to: '${PREFIX}'"
fi
mkdir -p "${PREFIX}"


case "$(uname -o)" in
  Msys)
	  INSTALL_X="install"
	  INSTALL_R="install"
	  INSTALL_P="install"
	  ;;
  *)
	  INSTALL_X="install -m 0755"
	  INSTALL_R="install -m 0644"
	  INSTALL_P="install -m 0700"
	  ;;
esac

# =============================================================================
# Exit on any errors
set -e
function echoerr() { echo "$@" 1>&2; }
# =============================================================================

# =============================================================================
# Configure some shell variables
PATH="${PATH}:${PREFIX}/.local/bin"
LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${PREFIX}/.local/lib"
DATAROOTDIR="${PREFIX}/.local/share"
# =============================================================================

# =============================================================================
# Autodetect current install capabilities
function has_prog() {
    hash "$1" > /dev/null 2>&1
    return $?
}

REQUIRED_PROGS=(curl git grep install mktemp sed tar)
has_errors=
for p in ${REQUIRED_PROGS[@]};
do
    if ! has_prog "${p}"; then
       echoerr " - ${p} required"
       has_errors=Yes
    fi
done
if ! has_prog uudecode && ! has_prog perl; then
    echoerr " - uudecode or perl required"
    has_errors=Yes
fi
[[ -z "${has_errors}" ]] || exit 1

os_name=
if has_prog uname; then
    os_name=$(uname -s)
fi
# =============================================================================

# =============================================================================
# Prepare temporary directory to unarchive files
# ----------------------------------------------
RUN_CWD=$(pwd)
SHAR_TMPDIR=$(mktemp -d)
cd "${SHAR_TMPDIR}"
echo "Unsharing files in '${SHAR_TMPDIR}' ..."
cat <<'SETUP_SHAR_EOF'> setup.shar
# @SHAR_ARCHIVE@
#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.15.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the '#!/bin/sh' line above, then type 'sh FILE'.
#
lock_dir=_sh17516
# Made on 2026-02-15 13:12 CET by <frede@white-fang>.
# Source directory was '/cygdrive/f/workspace/github/unix-config/src'.
#
# Existing files will *not* be overwritten, unless '-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    601 -rwxrwx--- data/config.site
#   2836 -rwxrwx--- data/tmux-256color.tinfo
#    486 -rwxrwx--- dot/bash_profile
#   3247 -rwxrwx--- dot/bashrc
#    219 -rwxrw-r-- dot/gdbinit
#     89 -rwxrwx--- dot/gemrc
#   2479 -rwxrwx--- dot/profile
#    995 -rwxrwx--- dot/tmux.conf
#   1489 -rwxrwx--- dot/vimrc
#    340 -rwxrwx--- dot/xprofile
#    832 -rwxrwx--- dot/Xresources
#    832 -rwxrwx--- dot/Xresources_user
#   4076 -rwxrwx--- dot/XWinrc
#    724 -rwxrw-r-- scripts/bshell.bat
#   2541 -rwxrwx--- scripts/byzanz-helper
#   8094 -rwxrwx--- scripts/codefmt
#   4685 -rwxrwx--- scripts/codemv
#   3766 -rwxrwx--- scripts/ffmpeg-helper
#   1820 -rwxrwx--- scripts/hyper-v
#   8007 -rwxrw-r-- scripts/msvc-shell
#  16939 -rwxrwx--- scripts/plgen
#    901 -rwxrwx--- scripts/runcron
#   3591 -rwxrwx--- scripts/sixel2tmux
#    332 -rwxrwx--- scripts/uudecode.pl
#   4128 -rwxrwx--- scripts/yank
#      1 -rwxrw---- libstdc++-v3/python/libstdcxx/__init__.py
#   1149 -rwxrw---- libstdc++-v3/python/libstdcxx/v6/__init__.py
# 110581 -rwxrw---- libstdc++-v3/python/libstdcxx/v6/printers.py
#  28943 -rwxrw---- libstdc++-v3/python/libstdcxx/v6/xmethods.py
#  13765 -rwxrwxr-x scripts/apt-cyg
#   3233 -rwxrw---- man/byzanz-helper.1
#   2788 -rwxrw---- man/codefmt.1
#   2846 -rwxrw---- man/codemv.1
#   3189 -rwxrw---- man/ffmpeg-helper.1
#   2645 -rwxrw---- man/hyper-v.1
#   3404 -rwxrw---- man/msvc-shell.1
#   4366 -rwxrw---- man/plgen.1
#   3949 -rwxrw---- man/sixel2tmux.1
#   4606 -rwxrw---- man/yank.1
#
MD5SUM=${MD5SUM-md5sum}
f=`${MD5SUM} --version | egrep '^md5sum .*(core|text)utils'`
test -n "${f}" && md5check=true || md5check=false
${md5check} || \
  echo 'Note: not verifying md5sums.  Consider installing GNU coreutils.'
if test "X$1" = "X-c"
then keep_file=''
else keep_file=true
fi
echo=echo
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=
locale_dir=
set_echo=false

for dir in $PATH
do
  if test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    case `$dir/gettext --version 2>&1 | sed 1q` in
      *GNU*) gettext_dir=$dir
      set_echo=true
      break ;;
    esac
  fi
done

if ${set_echo}
then
  set_echo=false
  for dir in $PATH
  do
    if test -f $dir/shar \
       && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
    then
      locale_dir=`$dir/shar --print-text-domain-dir`
      set_echo=true
      break
    fi
  done

  if ${set_echo}
  then
    TEXTDOMAINDIR=$locale_dir
    export TEXTDOMAINDIR
    TEXTDOMAIN=sharutils
    export TEXTDOMAIN
    echo="$gettext_dir/gettext -s"
  fi
fi
IFS="$save_IFS"
if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null
then if (echo -n test; echo 1,2,3) | grep n >/dev/null
     then shar_n= shar_c='
'
     else shar_n=-n shar_c= ; fi
else shar_n= shar_c='\c' ; fi
f=shar-touch.$$
st1=200112312359.59
st2=123123592001.59
st2tr=123123592001.5 # old SysV 14-char limit
st3=1231235901

if   touch -am -t ${st1} ${f} >/dev/null 2>&1 && \
     test ! -f ${st1} && test -f ${f}; then
  shar_touch='touch -am -t $1$2$3$4$5$6.$7 "$8"'

elif touch -am ${st2} ${f} >/dev/null 2>&1 && \
     test ! -f ${st2} && test ! -f ${st2tr} && test -f ${f}; then
  shar_touch='touch -am $3$4$5$6$1$2.$7 "$8"'

elif touch -am ${st3} ${f} >/dev/null 2>&1 && \
     test ! -f ${st3} && test -f ${f}; then
  shar_touch='touch -am $3$4$5$6$2 "$8"'

else
  shar_touch=:
  echo
  ${echo} 'WARNING: not restoring timestamps.  Consider getting and
installing GNU '\''touch'\'', distributed in GNU coreutils...'
  echo
fi
rm -f ${st1} ${st2} ${st2tr} ${st3} ${f}
#
if test ! -d ${lock_dir} ; then :
else ${echo} "lock directory ${lock_dir} exists"
     exit 1
fi
if mkdir ${lock_dir}
then ${echo} "x - created lock directory ${lock_dir}."
else ${echo} "x - failed to create lock directory ${lock_dir}."
     exit 1
fi
# ============= data/config.site ==============
if test ! -d 'data'; then
  mkdir 'data'
if test $? -eq 0
then ${echo} "x - created directory data."
else ${echo} "x - failed to create directory data."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'data/config.site'
then
${echo} "x - SKIPPING data/config.site (file already exists)"

else
${echo} "x - extracting data/config.site (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'data/config.site' &&
# ${HOME}/.local/etc/config.site for configure
#
# Change some defaults.
test "$prefix" = NONE && prefix="${HOME}/.local"
X
# Give Autoconf 2.x generated configure scripts a shared default
# cache file for feature test results, architecture-specific.
if test "$cache_file" = /dev/null; then
X  # A cache file is only valid for one C compiler.
X  if test -z "${CC}"; then
X    CC=gcc
X  fi
X
X  if hash "md5sum" > /dev/null 2>&1; then
X    md5=`echo "CFLAGS='${CFLAGS}' CXXFLAGS='${CXXFLAGS}' LDFLAGS='${LDFLAGS}'" | md5sum | awk '{print $1}'`
X    cache_file="${prefix}/var/config.cache.${CC}.${md5}"
X  fi
fi
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'data/config.site'
   eval "${shar_touch}") && \
  chmod 0770 'data/config.site'
if test $? -ne 0
then ${echo} "restore of data/config.site failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'data/config.site': 'MD5 check failed'
       ) << \SHAR_EOF
2ed65e831ddaf57e14ca86252615ceb3  data/config.site
SHAR_EOF

else
test `LC_ALL=C wc -c < 'data/config.site'` -ne 601 && \
  ${echo} "restoration warning:  size of 'data/config.site' is not 601"
  fi
fi
# ============= data/tmux-256color.tinfo ==============
if test ! -d 'data'; then
  mkdir 'data'
if test $? -eq 0
then ${echo} "x - created directory data."
else ${echo} "x - failed to create directory data."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'data/tmux-256color.tinfo'
then
${echo} "x - SKIPPING data/tmux-256color.tinfo (file already exists)"

else
${echo} "x - extracting data/tmux-256color.tinfo (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'data/tmux-256color.tinfo' &&
#       Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color
tmux-256color|tmux with 256 colors,
X        am, hs, km, mir, msgr, xenl,
X        colors#0x100, cols#80, it#8, lines#24, pairs#0x7fff,
X        acsc=++\,\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
X        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
X        clear=\E[H\E[J, cnorm=\E[34h\E[?25h, cr=\r,
X        csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H,
X        cud=\E[%p1%dB, cud1=\n, cuf=\E[%p1%dC, cuf1=\E[C,
X        cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\EM,
X        cvvis=\E[34l, dch=\E[%p1%dP, dch1=\E[P, dim=\E[2m,
X        dl=\E[%p1%dM, dl1=\E[M, dsl=\E]0;\007, ed=\E[J, el=\E[K,
X        el1=\E[1K, enacs=\E(B\E)0, flash=\Eg, fsl=^G, home=\E[H,
X        ht=^I, hts=\EH, ich=\E[%p1%d@, il=\E[%p1%dL, il1=\E[L,
X        ind=\n, is2=\E)0, kDC=\E[3;2~, kEND=\E[1;2F, kHOM=\E[1;2H,
X        kIC=\E[2;2~, kLFT=\E[1;2D, kNXT=\E[6;2~, kPRV=\E[5;2~,
X        kRIT=\E[1;2C, kbs=^H, kcbt=\E[Z, kcub1=\EOD, kcud1=\EOB,
X        kcuf1=\EOC, kcuu1=\EOA, kdch1=\E[3~, kend=\E[4~, kf1=\EOP,
X        kf10=\E[21~, kf11=\E[23~, kf12=\E[24~, kf13=\E[1;2P,
X        kf14=\E[1;2Q, kf15=\E[1;2R, kf16=\E[1;2S, kf17=\E[15;2~,
X        kf18=\E[17;2~, kf19=\E[18;2~, kf2=\EOQ, kf20=\E[19;2~,
X        kf21=\E[20;2~, kf22=\E[21;2~, kf23=\E[23;2~,
X        kf24=\E[24;2~, kf25=\E[1;5P, kf26=\E[1;5Q, kf27=\E[1;5R,
X        kf28=\E[1;5S, kf29=\E[15;5~, kf3=\EOR, kf30=\E[17;5~,
X        kf31=\E[18;5~, kf32=\E[19;5~, kf33=\E[20;5~,
X        kf34=\E[21;5~, kf35=\E[23;5~, kf36=\E[24;5~,
X        kf37=\E[1;6P, kf38=\E[1;6Q, kf39=\E[1;6R, kf4=\EOS,
X        kf40=\E[1;6S, kf41=\E[15;6~, kf42=\E[17;6~,
X        kf43=\E[18;6~, kf44=\E[19;6~, kf45=\E[20;6~,
X        kf46=\E[21;6~, kf47=\E[23;6~, kf48=\E[24;6~,
X        kf49=\E[1;3P, kf5=\E[15~, kf50=\E[1;3Q, kf51=\E[1;3R,
X        kf52=\E[1;3S, kf53=\E[15;3~, kf54=\E[17;3~,
X        kf55=\E[18;3~, kf56=\E[19;3~, kf57=\E[20;3~,
X        kf58=\E[21;3~, kf59=\E[23;3~, kf6=\E[17~, kf60=\E[24;3~,
X        kf61=\E[1;4P, kf62=\E[1;4Q, kf63=\E[1;4R, kf7=\E[18~,
X        kf8=\E[19~, kf9=\E[20~, khome=\E[1~, kich1=\E[2~,
X        kind=\E[1;2B, kmous=\E[M, knp=\E[6~, kpp=\E[5~,
X        kri=\E[1;2A, nel=\EE, op=\E[39;49m, rc=\E8, rev=\E[7m,
X        ri=\EM, ritm=\E[23m, rmacs=^O, rmcup=\E[?1049l, rmir=\E[4l,
X        rmkx=\E[?1l\E>, rmso=\E[27m, rmul=\E[24m,
X        rs2=\Ec\E[?1000l\E[?25h, sc=\E7,
X        setab=\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,
X        setaf=\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,
X        sgr=\E[0%?%p6%t;1%;%?%p1%t;3%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p5%t;2%;m%?%p9%t\016%e\017%;,
X        sgr0=\E[m\017, sitm=\E[3m, smacs=^N, smcup=\E[?1049h,
X        smir=\E[4h, smkx=\E[?1h\E=, smso=\E[7m, smul=\E[4m,
X        tbc=\E[3g, tsl=\E]0;,
SHAR_EOF
  (set 20 25 12 31 14 16 57 'data/tmux-256color.tinfo'
   eval "${shar_touch}") && \
  chmod 0770 'data/tmux-256color.tinfo'
if test $? -ne 0
then ${echo} "restore of data/tmux-256color.tinfo failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'data/tmux-256color.tinfo': 'MD5 check failed'
       ) << \SHAR_EOF
6ab6c2f0e9d36f696206c718d24287c3  data/tmux-256color.tinfo
SHAR_EOF

else
test `LC_ALL=C wc -c < 'data/tmux-256color.tinfo'` -ne 2836 && \
  ${echo} "restoration warning:  size of 'data/tmux-256color.tinfo' is not 2836"
  fi
fi
# ============= dot/bash_profile ==============
if test ! -d 'dot'; then
  mkdir 'dot'
if test $? -eq 0
then ${echo} "x - created directory dot."
else ${echo} "x - failed to create directory dot."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'dot/bash_profile'
then
${echo} "x - SKIPPING dot/bash_profile (file already exists)"

else
${echo} "x - extracting dot/bash_profile (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/bash_profile' &&
# .bash_profile executed by bash(1) for login shells.
export BASH_PROFILE_LOADED=yes
X
X. ~/.profile
X
if [ -d ~/.local/etc/profile.d ]; then
X    for profile_script in ~/.local/etc/profile.d/*.bash
X    do
X        [ -e "${profile_script}" ] || continue
X        . "${profile_script}"
X    done
fi
X
# Bash reads:
# - .bash_profile for interactive login shells
# - .bashrc for non-login intecactive shells.
#
# source the user's bashrc if it exists
if [ -f ~/.bashrc ]; then
X    . ~/.bashrc
fi
SHAR_EOF
  (set 20 26 02 15 11 25 38 'dot/bash_profile'
   eval "${shar_touch}") && \
  chmod 0770 'dot/bash_profile'
if test $? -ne 0
then ${echo} "restore of dot/bash_profile failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/bash_profile': 'MD5 check failed'
       ) << \SHAR_EOF
bb556884f61d24976ee7f53a805a0720  dot/bash_profile
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/bash_profile'` -ne 486 && \
  ${echo} "restoration warning:  size of 'dot/bash_profile' is not 486"
  fi
fi
# ============= dot/bashrc ==============
if test ! -d 'dot'; then
  mkdir 'dot'
if test $? -eq 0
then ${echo} "x - created directory dot."
else ${echo} "x - failed to create directory dot."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'dot/bashrc'
then
${echo} "x - SKIPPING dot/bashrc (file already exists)"

else
${echo} "x - extracting dot/bashrc (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/bashrc' &&
# If we didn't load the .bash_profile, do it now
# This can happen in windows when running 'bash -c xxx' from cmd.exe
if [ -z "${BASH_PROFILE_LOADED}" ]; then
X  . ~/.bash_profile
fi
# If not running interactively, don't do anything
[[ "$-" != *i* ]] && return
X
# Prompt customization
TPUT=$(which tput)
if [ -t 1 -a -n "${TPUT}" ]; then
X    NCOLORS=$(tput colors)
X    if [ -n "${NCOLORS}" -a "${NCOLORS}" -ge 8 ]; then
X        #BLACK_FG=$(tput setaf 0)
X        RED_FG=$(tput setaf 1)
X        GREEN_FG=$(tput setaf 2)
X        YELLOW_FG=$(tput setaf 3)
X        #BLUE_FG=$(tput setaf 4)
X        MAGENTA_FG=$(tput setaf 5)
X        CYAN_FG=$(tput setaf 6)
X        WHITE_FG=$(tput setaf 7)
X        DEFAULT_FG=$(tput sgr0)
X    fi
fi
X
case "${TERM}" in
X  *xterm* | tmux*)
X    SETXTERMTITLE='\[\e]0;\h - \w\a\]\n';
X    PS1="${SETXTERMTITLE}${PS1}"
X    ;;
esac
if [[ -n "${VIMRUNTIME}" ]]; then
X    VIM_LED="${RED_FG}[vim] "
fi
if [[ -n "${VS_KIT}" ]]; then
X    VS_LED="${CYAN_FG}[msvc ${VS_KIT} ${VS_VERSION:0:2}.${VS_VERSION:2:1}] "
fi
PS1="${SETXTERMTITLE}${VIM_LED}${VS_LED}${GREEN_FG}\\u@\\h ${MAGENTA_FG}\\t ${YELLOW_FG}\\w${DEFAULT_FG}\n\$ "
export PS1
X
# Make bash append rather than overwrite the history on disk
shopt -s histappend
X
# Don't put duplicate lines in the history.
export HISTCONTROL=$HISTCONTROL${HISTCONTROL+,}ignoredups
X
# Whenever displaying the prompt, write the previous line to disk
export PROMPT_COMMAND="history -a"
X
# Load bash-completion if available
if [ -f /usr/share/bash-completion/bash_completion ]; then
X    source /usr/share/bash-completion/bash_completion
fi
X
# Following line is usually added by travis gem for bash autocompletion
# added by travis gem
[ -f ~/.travis/travis.sh ] && source ~/.travis/travis.sh
X
# Aliases
#
# Some people use a different file for aliases
if [ -f "${HOME}/.bash_aliases" ]; then
X    source "${HOME}/.bash_aliases"
fi
alias grep='grep --color'                     # show differences in colour
alias egrep='egrep --color=auto'              # show differences in colour
alias fgrep='fgrep --color=auto'              # show differences in colour
X
# Some shortcuts for different directory listings
alias ls='ls -hF --color=tty'                 # classify files in colour
alias dir='ls --color=auto --format=vertical'
alias vdir='ls --color=auto --format=long'
alias ll='ls -l'                              # long list
alias la='ls -A'                              # all but . and ..
alias l='ls -CF'                              #
X
# Functions
#
# Some people use a different file for functions
if [ -f "${HOME}/.bash_functions" ]; then
X    source "${HOME}/.bash_functions"
fi
X
# Some example functions:
#
# a) function settitle
settitle ()
{
X    echo -ne "\e]2;$@\a\e]1;$@\a";
}
X
# b) function is_ssh_agent_running
is_ssh_agent_running()
{
X    ps -p "$1" | grep 'ssh-agent$' > /dev/null 2>&1
X    return $?
}
X
# Remote PulseAudio
# -----------------
# export PULSE_SERVER=tcp:localhost:4713
# export SDL_AUDIODRIVER=pulse
X
# SSH-AGENT sourcing
if [ -e ~/.ssh/ssh-agent.pid ]; then
X    source ~/.ssh/ssh-agent.pid > /dev/null 2>&1
fi
if ! is_ssh_agent_running "${SSH_AGENT_PID:-1}"; then
X    ssh-agent > ~/.ssh/ssh-agent.pid 2> /dev/null
X    source ~/.ssh/ssh-agent.pid > /dev/null 2>&1
fi
SHAR_EOF
  (set 20 26 02 15 11 24 42 'dot/bashrc'
   eval "${shar_touch}") && \
  chmod 0770 'dot/bashrc'
if test $? -ne 0
then ${echo} "restore of dot/bashrc failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/bashrc': 'MD5 check failed'
       ) << \SHAR_EOF
76b1ee37f2fbb40b7c9e6f8700f7b437  dot/bashrc
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/bashrc'` -ne 3247 && \
  ${echo} "restoration warning:  size of 'dot/bashrc' is not 3247"
  fi
fi
# ============= dot/gdbinit ==============
if test -n "${keep_file}" && test -f 'dot/gdbinit'
then
${echo} "x - SKIPPING dot/gdbinit (file already exists)"

else
${echo} "x - extracting dot/gdbinit (text)"
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 dot/gdbinit
M<'ET:&]N#0II;7!O<G0@<WES#0IF<F]M(&]S+G!A=&@@:6UP;W)T(&5X<&%N
M9'5S97(-"G-Y<RYP871H+FEN<V5R="@P+"!E>'!A;F1U<V5R*"=^)RDK)R\N
M;&]C86PO<VAA<F4O9V1B+W!Y=&AO;B<I#0IF<F]M(&QI8G-T9&-X>"YV-BYP
M<FEN=&5R<R!I;7!O<G0@<F5G:7-T97)?;&EB<W1D8WAX7W!R:6YT97)S#0IR
G96=I<W1E<E]L:6)S=&1C>'A?<')I;G1E<G,H3F]N92D-"F5N9`T*
`
end
SHAR_EOF
  (set 20 26 02 12 21 39 20 'dot/gdbinit'
   eval "${shar_touch}") && \
  chmod 0764 'dot/gdbinit'
if test $? -ne 0
then ${echo} "restore of dot/gdbinit failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/gdbinit': 'MD5 check failed'
       ) << \SHAR_EOF
6d063d98b45c6331d339db74cf46ef62  dot/gdbinit
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/gdbinit'` -ne 219 && \
  ${echo} "restoration warning:  size of 'dot/gdbinit' is not 219"
  fi
fi
# ============= dot/gemrc ==============
if test -n "${keep_file}" && test -f 'dot/gemrc'
then
${echo} "x - SKIPPING dot/gemrc (file already exists)"

else
${echo} "x - extracting dot/gemrc (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/gemrc' &&
gem: --user-install --bindir ~/.local/bin
install: --user-install --bindir ~/.local/bin
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/gemrc'
   eval "${shar_touch}") && \
  chmod 0770 'dot/gemrc'
if test $? -ne 0
then ${echo} "restore of dot/gemrc failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/gemrc': 'MD5 check failed'
       ) << \SHAR_EOF
41198829c505876f4deb88494421c002  dot/gemrc
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/gemrc'` -ne 89 && \
  ${echo} "restoration warning:  size of 'dot/gemrc' is not 89"
  fi
fi
# ============= dot/profile ==============
if test -n "${keep_file}" && test -f 'dot/profile'
then
${echo} "x - SKIPPING dot/profile (file already exists)"

else
${echo} "x - extracting dot/profile (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/profile' &&
# .profile executed by sh(1) for login shells.
X
# Save system paths the first time
if [ -z "${SYSTEM_PATH}" ] ; then
X    export SYSTEM_PATH="${PATH}"
X    export SYSTEM_LD_LIBRARY_PATH="${LD_LIBRARY_PATH}"
X    export SYSTEM_MANPATH="${MANPATH}"
X    export SYSTEM_PERL5LIB="${PERL5LIB}"
X    export SYSTEM_PKG_CONFIG_PATH="${PKG_CONFIG_PATH}"
else
X    export PATH="${SYSTEM_PATH}"
X    export LD_LIBRARY_PATH="${SYSTEM_LD_LIBRARY_PATH}"
X    export MANPATH="${SYSTEM_MANPATH}"
X    export PERL5LIB="${SYSTEM_PERL5LIB}"
X    export PKG_CONFIG_PATH="${SYSTEM_PKG_CONFIG_PATH}"
fi
X
if [ -f ~/.path_dirs ]; then
X    while read -r xtrad || [ -n "${xtrad}" ];
X    do
X        if echo "${xtrad}" | grep '^[[:space:]]*\(#.*\)\?$' > /dev/null 2>&1 ; then
X            continue
X        fi
X        # Set PATH so it includes user's private bin if it exists
X        if [ -d "${xtrad}/bin" ]; then
X            PATH="${xtrad}/bin${PATH:+:${PATH}}"
X        fi
X
X        # Set PATH so it includes user's private lib if it exists
X        if [ -d "${xtrad}/lib" ]; then
X            PATH="${xtrad}/lib${PATH:+:${PATH}}"
X            LD_LIBRARY_PATH="${xtrad}/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}"
X        fi
X
X        # Set PKG_CONFIG_PATH so it includes user's private if it exists
X        if [ -d "${xtrad}/lib/pkgconfig" ]; then
X            PKG_CONFIG_PATH="${xtrad}/lib/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}"
X        fi
X
X        # Set MANPATH so it includes users' private man if it exists
X        if [ -d "${xtrad}/man" ]; then
X            MANPATH="${xtrad}/man:${MANPATH}"
X        fi
X        if [ -d "${xtrad}/share/man" ]; then
X            MANPATH="${xtrad}/share/man:${MANPATH}"
X        fi
X
X        # Set INFOPATH so it includes users' private info if it exists
X        if [ -d "${xtrad}/info" ]; then
X            INFOPATH="${xtrad}/info${INFOPATH:+:${INFOPATH}}"
X        fi
X
X    done < ~/.path_dirs
fi
X
if [ -O ~/.paths ]; then
X    while read -r xtrad || [ -n "${xtrad}" ];
X    do
X        if echo "${xtrad}" | grep '^[[:space:]]*\(#.*\)\?$' > /dev/null 2>&1 ; then
X            continue
X        fi
X        PATH="${PATH}:${xtrad}"
X    done < ~/.paths
fi
X
export PATH
export LD_LIBRARY_PATH
export PKG_CONFIG_PATH
export MANPATH
export INFOPATH
X
# For nedit bug...
export XLIB_SKIP_ARGB_VISUALS=1
X
if [ -d ~/.local/etc/profile.d ]; then
X    for profile_script in ~/.local/etc/profile.d/*.sh
X    do
X        [ -e "${profile_script}" ] || continue
X        . "${profile_script}"
X    done
fi
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/profile'
   eval "${shar_touch}") && \
  chmod 0770 'dot/profile'
if test $? -ne 0
then ${echo} "restore of dot/profile failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/profile': 'MD5 check failed'
       ) << \SHAR_EOF
a06ac8c065a95711e0c59921981c5353  dot/profile
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/profile'` -ne 2479 && \
  ${echo} "restoration warning:  size of 'dot/profile' is not 2479"
  fi
fi
# ============= dot/tmux.conf ==============
if test -n "${keep_file}" && test -f 'dot/tmux.conf'
then
${echo} "x - SKIPPING dot/tmux.conf (file already exists)"

else
${echo} "x - extracting dot/tmux.conf (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/tmux.conf' &&
# --- general -------------------------------------------------------
set -g default-terminal "tmux-256color"
setw -g xterm-keys on
set -g set-clipboard on
setw -g mode-keys vi
set -s focus-events on
X
setw -q -g utf8 on
X
# c0-change-interval interval # prevents flooding to break Ctrl+C
# c0-change-trigger trigger   #
X
# --- display -------------------------------------------------------
set -g base-index 1         # start window numbering at 1
setw -g pane-base-index 1   # start pane numbering at 1
X
setw -g automatic-rename on # rename window to current program
set -g renumber-windows on  # rename window when window is closed
X
set -g set-titles on        # set terminal title
set -g set-titles-string '#h   #S   #I #W'
X
set -g display-panes-time 800 # longer pane indicator display time
set -g display-time 1000      # longer status indicator display time
set -g status-interval 10     # refresh status every 10 seconds
X
# activity
set -g monitor-activity on
set -g visual-activity off
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/tmux.conf'
   eval "${shar_touch}") && \
  chmod 0770 'dot/tmux.conf'
if test $? -ne 0
then ${echo} "restore of dot/tmux.conf failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/tmux.conf': 'MD5 check failed'
       ) << \SHAR_EOF
acdf6f05258d49883b689f9b8788ceb8  dot/tmux.conf
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/tmux.conf'` -ne 995 && \
  ${echo} "restoration warning:  size of 'dot/tmux.conf' is not 995"
  fi
fi
# ============= dot/vimrc ==============
if test -n "${keep_file}" && test -f 'dot/vimrc'
then
${echo} "x - SKIPPING dot/vimrc (file already exists)"

else
${echo} "x - extracting dot/vimrc (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/vimrc' &&
" In case usual windows move command doesn't work
" :nmap <silent> <A-Up> :wincmd k<CR>
" :nmap <silent> <A-Down> :wincmd j<CR>
" :nmap <silent> <A-Left> :wincmd h<CR>
" :nmap <silent> <A-Right> :wincmd l<CR>
X
" Highligth characters after 80th columns
set colorcolumn=80
highlight ColorColumn ctermbg=lightgrey guibg=lightgrey
X
" Use explorer in tree mode
let g:netrw_liststyle=3
X
" Use soft tabs, size 4
set tabstop=4 shiftwidth=4 expandtab
X
" Auto indent file
autocmd FileType *      set formatoptions=tcql nocindent comments&
autocmd FileType c,cpp  set formatoptions=croql cindent comments=sr:/*,mb:*,ex:*/,://
set autoindent
X
" Highlight searched targets
set hlsearch
X
" Show line numbers
set number
X
" Encoding utf8
set encoding=utf8
X
" Block cursor
let &t_SI.="\e[1 q"
let &t_EI.="\e[1 q"
let &t_ti.="\e[1 q"
let &t_te.="\e[1 q"
X
" Show cursor line
hi CursorLine cterm=NONE ctermbg=darkred ctermfg=white
hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white
set cursorline
nnoremap <Leader>c :set cursorcolumn!
X
set nocompatible              " be iMproved, required
X
syntax on
set ruler
X
set nu
set nobackup
set smarttab
set tabstop=4
set shiftwidth=4
set expandtab
X
" copy the current text selection to the system clipboard
if has('gui_running') || has('nvim') && exists('$DISPLAY')
X  noremap <Leader>y "+y
else
X  " copy to attached terminal using the yank(1) script:
X  noremap <silent> <Leader>y y:call system('yank', @0)<Return>
endif
X
hi Terminal ctermbg=black ctermfg=white
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/vimrc'
   eval "${shar_touch}") && \
  chmod 0770 'dot/vimrc'
if test $? -ne 0
then ${echo} "restore of dot/vimrc failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/vimrc': 'MD5 check failed'
       ) << \SHAR_EOF
22d0d0de5a3480f10e342ac0cf20c8fb  dot/vimrc
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/vimrc'` -ne 1489 && \
  ${echo} "restoration warning:  size of 'dot/vimrc' is not 1489"
  fi
fi
# ============= dot/xprofile ==============
if test -n "${keep_file}" && test -f 'dot/xprofile'
then
${echo} "x - SKIPPING dot/xprofile (file already exists)"

else
${echo} "x - extracting dot/xprofile (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/xprofile' &&
#!/usr/bin/env bash
X
# Some (most) session managers like 'gdm' pass the '-no-cppp' option to 'xrdb'
# which causes our .Xresources.user file to not be loaded.
#
# Our solution is to explicitly merge our .Xresources file in .xprofile which
# is (still) respected by these session managers.
[ -f ~/.Xresources ] && xrdb -merge ~/.Xresources
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/xprofile'
   eval "${shar_touch}") && \
  chmod 0770 'dot/xprofile'
if test $? -ne 0
then ${echo} "restore of dot/xprofile failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/xprofile': 'MD5 check failed'
       ) << \SHAR_EOF
b1e407df92b42487a43fde948050e652  dot/xprofile
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/xprofile'` -ne 340 && \
  ${echo} "restoration warning:  size of 'dot/xprofile' is not 340"
  fi
fi
# ============= dot/Xresources ==============
if test -n "${keep_file}" && test -f 'dot/Xresources'
then
${echo} "x - SKIPPING dot/Xresources (file already exists)"

else
${echo} "x - extracting dot/Xresources (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/Xresources' &&
#include ".Xresources.user"
X
XXTerm*eightBitInput: true
XXTerm*metaSendsEscape: true
XXTerm*renderFont: true
XXTerm*termName: xterm-256color
XXTerm*utf8Fonts: true
XXTerm*utf8Title: true
! Contrary to what the statement looks like, it is enabling the SetSelection
! window operation. The default value is: 20,21,SetXprop,SetSelection
XXTerm*disallowedWindowOps: 20,21,SetXprop
XXTerm*vt100.initialFont: 3
! Fix for the infamous Ctrl+H issue
! see: http://www.hypexr.org/linux_ruboff.php
!XTerm*ttyModes:         erase ^?
!XTerm*VT100.Translations: \
!  #override <Key>BackSpace: string(0x7f) \n\
!            <Key>Delete:    string(0x1b) string("[3~")
X
!XTerm*dynamicColors: true
!XTerm*backarrowKey: false
!XTerm*backarrowKeyIsErase: true
X
! Sixel enabling with more than 16 colors
XXTerm*decTerminalID: vt340
XXTerm*numColorRegisters: 256
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/Xresources'
   eval "${shar_touch}") && \
  chmod 0770 'dot/Xresources'
if test $? -ne 0
then ${echo} "restore of dot/Xresources failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/Xresources': 'MD5 check failed'
       ) << \SHAR_EOF
d940ccda727facdf3baa3adff082b1ab  dot/Xresources
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/Xresources'` -ne 832 && \
  ${echo} "restoration warning:  size of 'dot/Xresources' is not 832"
  fi
fi
# ============= dot/Xresources_user ==============
if test -n "${keep_file}" && test -f 'dot/Xresources_user'
then
${echo} "x - SKIPPING dot/Xresources_user (file already exists)"

else
${echo} "x - extracting dot/Xresources_user (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/Xresources_user' &&
! This file is preprocessed by 'cpp' which defines the following macros:
! X_RESOLUTION: the X resolution of the screen in pixel per meter
! Y_RESOLUTION: the Y resolution of the screen in pixel per meter
!
! By running `xrdb -symbols` we can inspect these macros for the current X
! session.
!
! We can use these macros to define the font face size of our XTerm.
#define XTERM_FACE_SIZE_MULTIPLE ((Y_RESOLUTION+3775)/3776)
X
XXTerm*faceName: DejaVuSansMono Nerd Font Mono
#if XTERM_FACE_SIZE_MULTIPLE == 1
XXTerm*faceSize: 14
#endif
#if XTERM_FACE_SIZE_MULTIPLE == 2
XXTerm*faceSize: 24
#endif
#if XTERM_FACE_SIZE_MULTIPLE >= 3
XXTerm*faceSize: 36
#endif
XXTerm*reverseVideo: false
XXTerm*foreground: white
XXTerm*background: black
XXTerm*rightScrollBar: true
XXTerm*scrollBar: true
XXTerm*toolBar: false
XXTerm*utf8: 2
XXTerm*visualBell: true
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/Xresources_user'
   eval "${shar_touch}") && \
  chmod 0770 'dot/Xresources_user'
if test $? -ne 0
then ${echo} "restore of dot/Xresources_user failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/Xresources_user': 'MD5 check failed'
       ) << \SHAR_EOF
e8970ffffd426e18f1287b1b6a1ea0e2  dot/Xresources_user
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/Xresources_user'` -ne 832 && \
  ${echo} "restoration warning:  size of 'dot/Xresources_user' is not 832"
  fi
fi
# ============= dot/XWinrc ==============
if test -n "${keep_file}" && test -f 'dot/XWinrc'
then
${echo} "x - SKIPPING dot/XWinrc (file already exists)"

else
${echo} "x - extracting dot/XWinrc (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'dot/XWinrc' &&
# XWin Server Resource File - EXAMPLE
# Earle F. Philhower, III
X
# Place in ~/.XWinrc or in /etc/X11/system.XWinrc
X
# Keywords are case insensitive, comments legal pretty much anywhere
# you can have an end-of-line
X
# Comments begin with "#" or "//" and go to the end-of-line
X
# Paths to commands are **cygwin** based (i.e. /usr/local/bin/xcalc)
X
# Paths to icons are **WINDOWS** based (i.e. c:\windows\icons)
X
# Menus are defined as...
# MENU <name> {
#	<Menu Text>	EXEC	<command>
#                               ^^ This command will have any "%display%"
#                                  string replaced with the proper display
#                                  variable (i.e. 127.0.0.1:<display>.0)
#                                  (This should only rarely be needed as
#                                  the DISPLAY environment variable is also
#                                  set correctly)
#  or	<Menu Text>	MENU	<name-of-some-prior-defined-menu>
#  or	<Menu Text>	ALWAYSONTOP
#                         ^^ Sets the window to display above all others
#  or   <Menu Text>	RELOAD
#                         ^^ Causes ~/.XWinrc or the system.XWinrc file
#                            to be reloaded and icons and menus regenerated
#  or	SEPARATOR
#       ...
# }
X
# Set the taskmar menu with
# ROOTMENU <name-of-some-prior-defined-menu>
X
# If you want a menu to be applied to all popup window's system menu
# DEFAULTSYSMENU <name-of-some-prior-defined-menu> <atstart|atend>
X
# To choose a specific menu for a specific WM_CLASS or WM_NAME use ...
# SYSMENU {
#	<class-or-name-of-window> <name-of-prior-defined-menu> <atstart|atend>
#	...
# }
X
# When specifying an ICONFILE in the following commands several different
# formats are allowed:
# 1. Name of a regular Windows .ico format file
#    (ex:  "cygwin.ico", "apple.ico")
# 2. Name and index into a Windows .DLL
#    (ex: "c:\windows\system32\shell32.dll,4" gives the default folder icon
#         "c:\windows\system32\shell32.dll,5" gives the floppy drive icon)
# 3. Index into XWin.EXE internal ICON resource
#    (ex: ",101" is the 1st icon inside XWin.exe)
X
# To define where ICO files live (** Windows path**)
# ICONDIRECTORY	<windows-path i.e. c:\cygwin\usr\icons>
# NOTE: If you specify a fully qualified path to an ICON below
#             (i.e. "c:\xxx" or "d:\xxxx")
#       this ICONDIRECTORY will not be prepended
X
# To change the taskbar icon use...
# TRAYICON       <name-of-windows-ico-file-in-icondirectory>
X
# To define a replacement for the standard X icon for apps w/o specified icons
# DEFAULTICON	<name-of-windows-ico-file-in-icondirectory>
X
# To define substitute icons on a per-window basis use...
# ICONS {
#	<class-or-name-of-window> <icon-file-name.ico>
#	...
# }
# In the case where multiple matches occur, the first listed in the ICONS
# section will be chosen.
X
# To disable exit confirmation dialog add the line containing SilentExit
X
# DEBUG <string> prints out the string to the XWin.log file
X
// Below are just some silly menus to demonstrate writing your
// own configuration file.
X
// Make some menus...
menu apps {
X	xterm	exec	"xterm"
X	"Emacs"	exec	"xterm -e emacs -nw"
X	notepad	exec	notepad
X	xload	exec	"xload -display %display%"  # Comment
}
X
menu root {
X        "xterm"         exec    "xterm"
X	SEPARATOR
X	"Applications"	menu	apps
// Comments fit here, too...
X
//	SEPARATOR
//	FAQ            EXEC "cygstart http://x.cygwin.com/docs/faq/cygwin-x-faq.html"
//	"User's Guide" EXEC "cygstart http://x.cygwin.com/docs/ug/cygwin-x-ug.html"
X	SEPARATOR
X	"View logfile" EXEC "xterm -e less +F $XWINLOGFILE"
X	SEPARATOR
X
X	"Reload .XWinrc"	RELOAD
X	SEPARATOR
}
X
menu aot {
X	Separator
X	"Always on Top"	alwaysontop
}
X
menu xtermspecial {
X        "XTerm" exec "xterm"
X	"Emacs"		exec	"xterm -e emacs -nw"
X	"Always on Top"	alwaysontop
X	SepArAtor
}
X
RootMenu root
X
DefaultSysMenu aot atend
X
SysMenu {
X	"xterm"	xtermspecial atstart
}
X
# IconDirectory	"c:\winnt\"
X
# DefaultIcon	"reinstall.ico"
X
# Icons {
# 	"xterm"	"uninstall.ico"
# }
X
SilentExit
X
DEBUG "Done parsing the configuration file..."
X
SHAR_EOF
  (set 20 25 12 31 14 16 57 'dot/XWinrc'
   eval "${shar_touch}") && \
  chmod 0770 'dot/XWinrc'
if test $? -ne 0
then ${echo} "restore of dot/XWinrc failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'dot/XWinrc': 'MD5 check failed'
       ) << \SHAR_EOF
061681de2263a9bb820392d2cbe1faaa  dot/XWinrc
SHAR_EOF

else
test `LC_ALL=C wc -c < 'dot/XWinrc'` -ne 4076 && \
  ${echo} "restoration warning:  size of 'dot/XWinrc' is not 4076"
  fi
fi
# ============= scripts/bshell.bat ==============
if test ! -d 'scripts'; then
  mkdir 'scripts'
if test $? -eq 0
then ${echo} "x - created directory scripts."
else ${echo} "x - failed to create directory scripts."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'scripts/bshell.bat'
then
${echo} "x - SKIPPING scripts/bshell.bat (file already exists)"

else
${echo} "x - extracting scripts/bshell.bat (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/bshell.bat' &&
@echo off
X
rem We can configure the windows terminal to use MSYS2 using the
rem `bshell.bat` script:
rem 
rem ----
rem cmd.exe /k "bshell.bat --ucrt64"
rem ----
X
set arg=%1
X
if "%arg%" == "--help" goto:argHelp
if "%arg%" == "-h" goto:argHelp
if "%arg%" == "" goto:argHelp
if "%arg%" == "--git-bash" goto:runGitBash
if "%arg%" == "--ucrt64" goto:runUcrt64
goto:unknownArg
X
:runGitBash
"%PROGRAMFILES%\Git\bin\bash.exe" -l -i
goto:end
X
:runUcrt64
set MSYSTEM=UCRT64
set MSYS2_PATH_TYPE=inherit
"C:\msys64\usr\bin\bash" -l -i
goto:end
X
:printHelp
echo Usage:
echo     %~1 -h^|--help
echo     %~1 --git-bash^|--ucrt64
goto:eof
X
:unknownArg
call:printHelp %0
set errorlevel=1
goto:end
X
:argHelp
call:printHelp %0
goto:end
X
:end
X
SHAR_EOF
  (set 20 26 02 12 21 39 20 'scripts/bshell.bat'
   eval "${shar_touch}") && \
  chmod 0764 'scripts/bshell.bat'
if test $? -ne 0
then ${echo} "restore of scripts/bshell.bat failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/bshell.bat': 'MD5 check failed'
       ) << \SHAR_EOF
42f129b116ccfbe9f581ab43c7d7f58c  scripts/bshell.bat
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/bshell.bat'` -ne 724 && \
  ${echo} "restoration warning:  size of 'scripts/bshell.bat' is not 724"
  fi
fi
# ============= scripts/byzanz-helper ==============
if test ! -d 'scripts'; then
  mkdir 'scripts'
if test $? -eq 0
then ${echo} "x - created directory scripts."
else ${echo} "x - failed to create directory scripts."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'scripts/byzanz-helper'
then
${echo} "x - SKIPPING scripts/byzanz-helper (file already exists)"

else
${echo} "x - extracting scripts/byzanz-helper (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/byzanz-helper' &&
#!/usr/bin/env perl
X
use 5.008000;
use strict;
use warnings 'all';
X
use Carp;
use Cwd;
use File::Basename;
use File::Temp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case);
use Pod::Usage;
X
X
# Parse options
my ($opt_help, $opt_t, $opt_o);
GetOptionsFromArray(
X    \@ARGV,
X    'help|h'       => \$opt_help,
X    't|duration=s' => \$opt_t,
X    'o|output=s'   => \$opt_o,
) or croak('Error parsing command line arguments');
X
# Handle help option
pod2usage(-exitval => 0) if ($opt_help);
X
if(!defined($opt_o) || $opt_o eq '') {
X    print STDERR "Option '-o' or '--output' is mandatory\n";
X    pod2usage(-exitval => 1);
}
X
# Default option values
$opt_t //= 30;
X
# Get the recorded window parameters
my $xwin_info = `xwininfo`;
croak('Error getting X-Window information') if($?);
X
my ($x, $y, $width, $height);
$xwin_info =~ m/Absolute upper-left X:\s*(\d+)/g;
$x = $1;
$xwin_info =~ m/Absolute upper-left Y:\s*(\d+)/g;
$y = $1;
$xwin_info =~ m/Width:\s*(\d+)/g;
$width = $1;
$xwin_info =~ m/Height:\s*(\d+)/g;
$height = $1;
X
print "Recording area: [$x,$y -> $width,$height]\n";
exec "byzanz-record", "-d", $opt_t, "-x", $x, "-y", $y, "-w", $width, "-h", $height, $opt_o;
X
__END__
=head1 NAME
X
byzanz-helper - Helper script to record an X-Window with byzanz-record
X
=head1 SYNOPSIS
X
B<byzanz-helper> B<-h>|B<--help>
X
B<byzanz-helper> [B<OPTIONS>] B<-o> I<FILE>
X
=head1 DESCRIPTION
X
This tool helps record a specific B<X11> window using B<byzanz-record>. When
run, the script will ask the user to pick the desired X-Window using the mouse.
The recording will then start for the specified duration.
X
Internally the script uses B<xwininfo> to obtain the position and size of the
recorded video. These parameters are not updated while the video is recorded.
It the recorded window is moved it will leave the area of recording and be
only partially visible in the resulting video.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-o> I<FILE>|B<--output>=I<FILE>
X
Sets the output file for the recorded video.
X
=item B<-t> I<DURATION>|B<--duration>=I<DURATION>
X
Sets the recording duration in seconds. Default is 30 seconds.
X
=back
X
=head1 SEE ALSO
X
byzanz-record(1), byzanz-playback(1), xwininfo(1)
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2018 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the MIT license.
X
=cut
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/byzanz-helper'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/byzanz-helper'
if test $? -ne 0
then ${echo} "restore of scripts/byzanz-helper failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/byzanz-helper': 'MD5 check failed'
       ) << \SHAR_EOF
ba44a6190023b1b48776340b2bb6a277  scripts/byzanz-helper
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/byzanz-helper'` -ne 2541 && \
  ${echo} "restoration warning:  size of 'scripts/byzanz-helper' is not 2541"
  fi
fi
# ============= scripts/codefmt ==============
if test -n "${keep_file}" && test -f 'scripts/codefmt'
then
${echo} "x - SKIPPING scripts/codefmt (file already exists)"

else
${echo} "x - extracting scripts/codefmt (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/codefmt' &&
#!/usr/bin/env perl
#*===========================================================================*
#*                                                                           *
#*  codefmt - Code formatting tool                                           *
#*                                                                           *
#*  Copyright (c) 2019 Frederic Jardon  <frederic.jardon@gmail.com>          *
#*                                                                           *
#*  ------------------ GPL Licensed Source Code ------------------           *
#*  Frederic Jardon makes this software available under the GNU              *
#*  General Public License (GPL) license for open source projects.           *
#*  For details of the GPL license please see www.gnu.org or read            *
#*  the file license.gpl provided in this package.                           *
#*                                                                           *
#*  This program is free software; you can redistribute it and/or            *
#*  modify it under the terms of the GNU General Public License as           *
#*  published by the Free Software Foundation; either version 3 of           *
#*  the License, or (at your option) any later version.                      *
#*                                                                           *
#*  This program is distributed in the hope that it will be useful,          *
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
#*  GNU General Public License for more details.                             *
#*                                                                           *
#*  You should have received a copy of the GNU General Public                *
#*  License along with this program in the file 'license.gpl'; if            *
#*  not, see <http://www.gnu.org/licenses/>.                                 *
#*  --------------------------------------------------------------           *
#*===========================================================================*
X
use strict;
use warnings 'all';
use Data::Dumper;
use Carp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case pass_through);
use List::Util qw(max sum);
use Pod::Usage;
X
sub shuffle_words_in_columns {
X    my %args = @_;
X    croak "words is not defined" if (!defined ($args{words}));
X    croak "fmt is not defined"   if (!defined ($args{fmt}));
X
X    my @words = @{$args{words}};
X    my $fmt   = $args{fmt};
X
X    my $n_cols = length ($fmt);
X    my $n_rows = int ((@words+$n_cols-1)/$n_cols);
X    my @cols   = ();
X    for (my $i=0; $i<$n_cols; ++$i) {
X        my @indexes = map { $i+$n_cols*$_ } (0..($n_rows-1));
X        my @column  = map { $_ //= '' } @words[@indexes];
X        push (@cols, \@column);
X    }
X    return @cols;
}
X
sub line_width {
X    my %args = @_;
X
X    croak "cols is not defined" if (!defined ($args{cols}));
X
X    my @cols      = @{$args{cols}};
X    my $textwidth = $args{textwidth};
X    my $c_sep     = $args{separator};
X    my $eol_sep   = $args{eol_separator};
X    $textwidth  //= 70;
X    $c_sep      //= ' ';
X    $eol_sep    //= ' \\';
X
X    my $n_cols = @cols;
X    my @widths = map { max (map scalar @{$_} ) } @cols;
X    my $width  = ($n_cols - 1)*length ($c_sep) + sum (@widths) + length ($eol_sep);
X    return $width;
}
X
X
sub format_args {
X    my ($fmt, @args) = @_;
X    $^A = '';
X    formline ($fmt, @args);
X    return ''.$^A;
}
X
sub format_columns_to_lines {
X    my %args = @_;
X
X    croak "cols is not defined"     if (!defined ($args{cols}));
X    croak "fmt is not defined"      if (!defined ($args{fmt}));
X    croak "n_words is not defined"  if (!defined ($args{n_words}));
X
X    my @cols      = @{$args{cols}};
X    my $fmt       = $args{fmt};
X    my $textwidth = $args{textwidth};
X    my $c_sep     = $args{separator};
X    my $eol_sep   = $args{eol_separator};
X    my $n_words   = $args{n_words};
X    $textwidth  //= 70;
X    $c_sep      //= ' ';
X    $eol_sep    //= ' \\';
X
X    my $eol_len   = length ($eol_sep);
X    my $n_cols    = scalar @cols;
X    my @c_indexes = (0..$#cols);
X    my @widths    = map {
X                        my $col = $_;
X                        max (map {length ($_)} @{$col})
X                    } @cols;
X
X    my @perl_fmta = map {
X                        my ($c, $width) = (substr ($fmt, $_, 1), $widths[$_]);
X                        $width -= 1;
X                        my $r = '@'.'<'x$width;
X                        $r = '@'.'|'x$width if ($c eq 'c');
X                        $r = '@'.'>'x$width if ($c eq 'r');
X                        $r;
X                    } @c_indexes;
X    my $perl_fmt  = join ($c_sep, @perl_fmta);
X    $perl_fmt    .= ' ^'.('<'x($eol_len-1))."\n";
X
X    my $last_n_cols = $n_cols-((-$n_words) % $n_cols);
X    my @last_c_indexes = (0..($last_n_cols-1));
X    my @last_perl_fmta = @perl_fmta[@last_c_indexes];
X    my $last_perl_fmt  = join ($c_sep, @last_perl_fmta);
X
X    my $n_lines   = @{$cols[0]};
X    my @l_indexes = (0..($n_lines-2));
X    my @lines     = map {
X                        my $l_no = $_;
X                        my @words = map { $_->[$l_no] } @cols;
X                        push (@words, $eol_sep);
X                        format_args ($perl_fmt, @words)
X                    } @l_indexes;
X    my $last_line = format_args ($last_perl_fmt, map { $_->[$n_lines-1] } @cols);
X    $last_line =~ s/[ \t]*$//g;
X    push (@lines, $last_line);
X    return @lines;
}
X
# CLI arguments processing
my ($opt_help,
X    $opt_fmt,
X    $opt_eol,
X    $opt_prefix,
X    $opt_separator,
X    $opt_textwidth,
);
X
GetOptionsFromArray(\@ARGV,
X    'h|help'         => \$opt_help,
X    'f|format=s'     => \$opt_fmt,
X    'e|eol=s'        => \$opt_eol,
X    'p|prefix=s'     => \$opt_prefix,
X    's|separator=s'  => \$opt_separator,
X    'w|width=i'      => \$opt_textwidth,
) or croak "Error while parsing command-line arguments";
X
# Handle help option
pod2usage(-exitval => 0) if ($opt_help);
X
$opt_fmt       //= 'lll';
$opt_eol       //= " \\";
$opt_prefix    //= '    ';
$opt_separator //= ' ';
$opt_textwidth //= 70;
X
my @words = ();
while (<>) {
X    chomp;
X    my @line = ();
X    while ($_ ne '') {
X        my $word = undef;
X        if ($_ =~ s/^[ \t]*\Q$opt_eol\E$//g) {
X            last;
X        }
X        elsif ($_ =~ s/^[ \t]*\Q$opt_separator\E//g) {
X            next;
X        }
X        elsif ($_ =~ s/^[ \t]+//g) {
X            next;
X        }
X        elsif ($_ =~ s/^("([^"\\]|\\.)*")//g) {
X            push (@line, $1);
X        }
X        elsif ($_ =~ s/^('([^'\\]|\\.)*')//g) {
X            push (@line, $1);
X        }
X        elsif ($_ =~ s/^([^ \t]+)//g) {
X            push (@line, $1);
X        }
X        else {
X            croak "Unexpected tokens: '".quotemeta($_)."'";
X        }
X    }
X    next if (! @line);
X    push (@words, @line);
}
X
if (0 == @words) {
X    exit 0;
}
X
X
my @cols  = shuffle_words_in_columns (words => \@words, fmt => $opt_fmt);
my @lines = format_columns_to_lines (cols => \@cols, fmt => $opt_fmt, separator => $opt_separator, eol_separator => $opt_eol, n_words => scalar @words);
foreach my $line (@lines) {
X    print $opt_prefix.$line;
}
X
Xexit 0;
X
__END__
=head1 NAME
X
codefmt - Code Formatter tool
X
=head1 SYNOPSIS
X
B<codefmt> B<-h>|B<--help>
X
B<codefmt> [B<OPTIONS>] [B<FILE> ...]
X
=head1 DESCRIPTION
X
This tool format tabular data into fixed size columns.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-e> I<EOL-SEPARATOR>|B<--eol>=I<EOL-SEPARATOR>
X
Sets the end-of-line separator. Default value is: C< \\>.
X
=item B<-s> I<COLUMN-SEPARATOR>|B<--separator>=I<COLUMN-SEPARATOR>
X
Sets the end-of-line separator. Default value is: C< >.
X
=back
X
=head1 SEE ALSO
X
fmt(1), column(1), codemv(1)
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2019 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the GPL license.
X
=cut
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/codefmt'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/codefmt'
if test $? -ne 0
then ${echo} "restore of scripts/codefmt failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/codefmt': 'MD5 check failed'
       ) << \SHAR_EOF
1d3f96584042667191108c7b9ddc345b  scripts/codefmt
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/codefmt'` -ne 8094 && \
  ${echo} "restoration warning:  size of 'scripts/codefmt' is not 8094"
  fi
fi
# ============= scripts/codemv ==============
if test -n "${keep_file}" && test -f 'scripts/codemv'
then
${echo} "x - SKIPPING scripts/codemv (file already exists)"

else
${echo} "x - extracting scripts/codemv (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/codemv' &&
#!/usr/bin/env perl
#*===========================================================================*
#*                                                                           *
#*  codemv - Code formatting tool                                           *
#*                                                                           *
#*  Copyright (c) 2019 Frederic Jardon  <frederic.jardon@gmail.com>          *
#*                                                                           *
#*  ------------------ GPL Licensed Source Code ------------------           *
#*  Frederic Jardon makes this software available under the GNU              *
#*  General Public License (GPL) license for open source projects.           *
#*  For details of the GPL license please see www.gnu.org or read            *
#*  the file license.gpl provided in this package.                           *
#*                                                                           *
#*  This program is free software; you can redistribute it and/or            *
#*  modify it under the terms of the GNU General Public License as           *
#*  published by the Free Software Foundation; either version 3 of           *
#*  the License, or (at your option) any later version.                      *
#*                                                                           *
#*  This program is distributed in the hope that it will be useful,          *
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
#*  GNU General Public License for more details.                             *
#*                                                                           *
#*  You should have received a copy of the GNU General Public                *
#*  License along with this program in the file 'license.gpl'; if            *
#*  not, see <http://www.gnu.org/licenses/>.                                 *
#*  --------------------------------------------------------------           *
#*===========================================================================*
X
use strict;
use warnings 'all';
use Data::Dumper;
use Carp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case pass_through);
use List::Util qw(max sum);
use Pod::Usage;
X
sub usage {
X    my $exitval = scalar @_;
X    map { print STDERR "ERROR: ".$_."\n" } @_;
X    pod2usage(-exitval => $exitval);
}
X
# CLI arguments processing
my ($opt_help,
X    $opt_append,
X    $opt_copy,
X    $opt_end_string,
X    $opt_extract,
X    $opt_overwrite,
X    $opt_start_string,
);
X
GetOptionsFromArray(\@ARGV,
X    'h|help'         => \$opt_help,
X    'a|append=s'     => \$opt_append,
X    'c|copy'         => \$opt_copy,
X    'e|end=s'        => \$opt_end_string,
X    'o|overwrite=s'  => \$opt_overwrite,
X    's|start=s'      => \$opt_start_string,
X    'x|extract'      => \$opt_extract,
) or croak "Error while parsing command-line arguments";
X
# Handle help option
usage if ($opt_help);
usage("Options: '-a' and '-o' are mutually exclusive") if (defined($opt_append) and defined($opt_overwrite));
usage("Options: '-c' and '-x' are mutually exclusive") if (defined($opt_copy) and defined($opt_extract));
X
my ($open_mode, $filename);
$open_mode = '>>' if(defined($opt_append));
$open_mode = '>'  if(defined($opt_overwrite));
$filename //= $opt_append;
$filename //= $opt_overwrite;
usage("One option out of '-a' or '-o' is required") if(!defined($open_mode));
X
X
open(FILE, $open_mode, $filename) or die("Unable to open: '".$filename."'");
while(my $line = <STDIN>) {
X    print STDOUT $line if(defined($opt_copy));
X    print FILE $line;
}
close(FILE);
X
X
Xexit 0;
X
__END__
=head1 NAME
X
codemv - Code Mover Tool
X
=head1 SYNOPSIS
X
B<codemv> B<-h>|B<--help>
X
B<codemv> [B<OPTIONS>]...
X
=head1 DESCRIPTION
X
This tool divert part of its input to a specified file.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-a> I<FILE>|B<--append>=I<FILE>
X
Sets the file where diverted input is appended. This option is mutually
exclusive with the B<-o> option.
X
=item B<-c>|B<--copy>
X
Copy to stdout the whole input.
X
=item B<-o> I<FILE>|B<--overwrite>=I<FILE>
X
Sets the file overwritten by the diverted input. This option is mutually
exclusive with the B<-o> option.
X
=back
X
=head1 SEE ALSO
X
fmt(1), column(1), codefmt(1)
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2019 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the GPL license.
X
=cut
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/codemv'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/codemv'
if test $? -ne 0
then ${echo} "restore of scripts/codemv failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/codemv': 'MD5 check failed'
       ) << \SHAR_EOF
d10a4c05ffb485a81e7ce95721c40e8a  scripts/codemv
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/codemv'` -ne 4685 && \
  ${echo} "restoration warning:  size of 'scripts/codemv' is not 4685"
  fi
fi
# ============= scripts/ffmpeg-helper ==============
if test -n "${keep_file}" && test -f 'scripts/ffmpeg-helper'
then
${echo} "x - SKIPPING scripts/ffmpeg-helper (file already exists)"

else
${echo} "x - extracting scripts/ffmpeg-helper (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/ffmpeg-helper' &&
#!/usr/bin/env perl
X
use 5.008000;
use strict;
use warnings 'all';
X
use Carp;
use Cwd;
use File::Basename;
use File::Temp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case);
use Pod::Usage;
use POSIX qw(uname);
X
X
# Parse options
my ($opt_help, $opt_t, $opt_o);
GetOptionsFromArray(
X    \@ARGV,
X    'help|h'       => \$opt_help,
X    't|duration=s' => \$opt_t,
X    'o|output=s'   => \$opt_o,
) or croak('Error parsing command line arguments');
X
# Handle help option
pod2usage(-exitval => 0) if ($opt_help);
X
if(!defined($opt_o) || $opt_o eq '') {
X    print STDERR "Option '-o' or '--output' is mandatory\n";
X    pod2usage(-exitval => 1);
}
X
# Default option values
$opt_t //= 30;
X
# Get the recorded window parameters
my $xwin_info = `xwininfo`;
croak('Error getting X-Window information') if($?);
X
my ($title, $x, $y, $width, $height);
$xwin_info =~ m/Window id:\s+\w+\s+"([^"]+)"/g;
$title = $1;
$xwin_info =~ m/Absolute upper-left X:\s*(\d+)/g;
$x = $1;
$xwin_info =~ m/Absolute upper-left Y:\s*(\d+)/g;
$y = $1;
$xwin_info =~ m/Width:\s*(\d+)/g;
$width = $1;
$xwin_info =~ m/Height:\s*(\d+)/g;
$height = $1;
X
my $tmp = File::Temp->new(SUFFIX => '.mkv');
close($tmp);
my $mkv = "$tmp";
X
my ($sysname) = uname;
if($sysname =~ m/CYGWIN/) {
X    my @args = ("ffmpeg");
X    push(@args, '-video_size', $width.'x'.$height);
X    push(@args, '-framerate', '25');
X    push(@args, '-f', 'gdigrab');
X    push(@args, '-i', 'title='.$title);
X    push(@args, '-c:v', 'libx264', '-crf', '0', '-preset', 'ultrafast');
X    push(@args, $mkv);
X    my $cmd_cli = "'".join("' '", @args)."'";
X    print "system $cmd_cli\n";
X    system @args == 0
X        or die("Unable to execute command: $cmd_cli");
} else {
X    my @args = ("ffmpeg");
X    push(@args, '-video_size', $width.'x'.$height);
X    push(@args, '-framerate', '25');
X    push(@args, '-f', 'x11grab');
X    push(@args, '-i', ':0.0+'.$x.','.$y);
X    push(@args, '-c:v', 'libx264', '-crf', '0', '-preset', 'ultrafast');
X    push(@args, $mkv);
X    my $cmd_cli = "'".join("' '", @args)."'";
X    print "system $cmd_cli\n";
X    system @args == 0
X        or die("Unable to execute command: $cmd_cli");
}
X
my @args = ();
push(@args, 'ffmpeg');
push(@args, '-i', $mkv);
push(@args, '-c:v', 'libvpx-vp9', '-crf', '0', '-preset', 'veryslow');
push(@args, $opt_o);
my $cmd_cli = "'".join("' '", @args)."'";
print "system $cmd_cli\n";
system @args == 0
X    or die("Unable to execute command: $cmd_cli");
X
__END__
=head1 NAME
X
ffmpeg-helper - Helper script to record an X-Window with ffmpeg-record
X
=head1 SYNOPSIS
X
B<ffmpeg-helper> B<-h>|B<--help>
X
B<ffmpeg-helper> [B<OPTIONS>] B<-o> I<FILE>
X
=head1 DESCRIPTION
X
This tool helps record a specific B<X11> window using B<ffmpeg>. When
run, the script will ask the user to pick the desired X-Window using the mouse.
The recording will then start for the specified duration.
X
Internally the script uses B<xwininfo> to obtain the position and size of the
recorded video. These parameters are not updated while the video is recorded.
It the recorded window is moved it will leave the area of recording and be
only partially visible in the resulting video.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-o> I<FILE>|B<--output>=I<FILE>
X
Sets the output file for the recorded video.
X
=item B<-t> I<DURATION>|B<--duration>=I<DURATION>
X
Sets the recording duration in seconds. Default is 30 seconds.
X
=back
X
=head1 SEE ALSO
X
ffmpeg(1), xwininfo(1)
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2018 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the MIT license.
X
=cut
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/ffmpeg-helper'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/ffmpeg-helper'
if test $? -ne 0
then ${echo} "restore of scripts/ffmpeg-helper failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/ffmpeg-helper': 'MD5 check failed'
       ) << \SHAR_EOF
730d1c68192b332ed5091a88717971de  scripts/ffmpeg-helper
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/ffmpeg-helper'` -ne 3766 && \
  ${echo} "restoration warning:  size of 'scripts/ffmpeg-helper' is not 3766"
  fi
fi
# ============= scripts/hyper-v ==============
if test -n "${keep_file}" && test -f 'scripts/hyper-v'
then
${echo} "x - SKIPPING scripts/hyper-v (file already exists)"

else
${echo} "x - extracting scripts/hyper-v (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/hyper-v' &&
#!/usr/bin/env perl
X
use 5.008000;
use strict;
use warnings 'all';
X
use Carp;
use Cwd;
use File::Basename;
use File::Temp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case);
use Pod::Usage;
X
# Parse options
my ($opt_help, $opt_start, $opt_stop);
my $ret = GetOptionsFromArray(
X    \@ARGV,
X    'help|h' => \$opt_help,
X    'start'  => \$opt_start,
X    'stop'   => \$opt_stop,
);
pod2usage(-exitval => 1, -message => 'Unknown options: '.join(', ', @ARGV)) if(@ARGV);
pod2usage(-exitval => 1) if(!$ret);
X
# Handle help option
pod2usage(-exitval => 0) if $opt_help;
X
# Handle bad arguments
pod2usage(-exitval => 1)
X    if(!$opt_start && !$opt_stop);
pod2usage(-exitval => 1, -message => '--start and --stop are exclusive')
X    if($opt_start && $opt_stop);
X
my @command = ('bcdedit', '/set', 'hypervisorlaunchtype');
push(@command, 'auto') if ($opt_start);
push(@command, 'off')  if ($opt_stop);
X
system (@command);
X
__END__
=head1 NAME
X
hyper-v - Starts and stop the hyper-v windows hypervisor
X
=head1 SYNOPSIS
X
B<hyper-v> B<-h>|B<--help>
X
B<hyper-v> --start
X
B<hyper-v> --stop
X
=head1 DESCRIPTION
X
This tools enables or disables the hyper-v service on Windows 10. Note that for
the change to take effect one has to reboot the computer.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<start>
X
Mark the hyper-v service as running the next time windows starts.
X
=item B<stop>
X
Mark the hyper-v service as not running the next time windows starts.
X
=back
X
=head1 SEE ALSO
X
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2018 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the MIT license.
X
=cut
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/hyper-v'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/hyper-v'
if test $? -ne 0
then ${echo} "restore of scripts/hyper-v failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/hyper-v': 'MD5 check failed'
       ) << \SHAR_EOF
931cccf0a443d53c5f44be782f9a4583  scripts/hyper-v
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/hyper-v'` -ne 1820 && \
  ${echo} "restoration warning:  size of 'scripts/hyper-v' is not 1820"
  fi
fi
# ============= scripts/msvc-shell ==============
if test -n "${keep_file}" && test -f 'scripts/msvc-shell'
then
${echo} "x - SKIPPING scripts/msvc-shell (file already exists)"

else
${echo} "x - extracting scripts/msvc-shell (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/msvc-shell' &&
#!/usr/bin/env perl
X
#*  Copyright (c) 2017-2026 Frederic Jardon  <frederic.jardon@gmail.com>
#*
#*  ------------------ GPL Licensed Source Code ------------------
#*  Frederic Jardon makes this software available under the GNU
#*  General Public License (GPL) license for open source projects.
#*  For details of the GPL license please see www.gnu.org or read
#*  the file license.gpl provided in this package.
#*
#*  This program is free software; you can redistribute it and/or
#*  modify it under the terms of the GNU General Public License as
#*  published by the Free Software Foundation; using version 3 of 
#*  the License.
#*
#*  This program is distributed in the hope that it will be useful,
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*  GNU General Public License for more details.
#*
#*  You should have received a copy of the GNU General Public
#*  License along with this program in the file 'license.gpl'; if
#*  not, see <http://www.gnu.org/licenses/>.
#*  --------------------------------------------------------------
X
use strict;
use warnings 'all';
X
require Carp;
require Cwd;
require File::Basename;
require Getopt::Long;
require Storable;
X
use File::Temp;
X
sub call_vcvarsall {
X    my ($opts) = @_;
X
X    # Save current context to restore it later
X    my %saved_ENV = (%ENV);
X    my $cwd = Cwd::getcwd;
X
X    # Get environment
X    my $env = $opts->{ENV};
X    $env //= \%ENV;
X
X    # Get path to comspec
X    my $comspec_win=$env->{'COMSPEC'};
X    Carp::croak("Unable to find 'COMSPEC' in the environment!")
X        if(!defined($comspec_win));
X    my $comspec_path = Cygwin::win_to_posix_path($comspec_win);
X
X    # Get path to vcvarsall.bat
X    my $vcvarsall_bat_path = $opts->{vcvarsall_bat_path};
X    Carp::croak("'vcvarsall_bat_path' parameter is mandatory")
X        if(!defined($vcvarsall_bat_path));
X
X    # Get vcvarsall.bat arguments
X    my $vcvarsall_args = $opts->{args};
X    $vcvarsall_args  //= [];
X
X    # Get paths to scripts and bash
X    my $bat_dir      = File::Basename::dirname($vcvarsall_bat_path);
X    my $bat_dir_win  = Cygwin::posix_to_win_path($bat_dir);
X    my $bat_path_win = Cygwin::posix_to_win_path($vcvarsall_bat_path);
X    my $bash_dir     ='/usr/bin';
X    my $bash_dir_win = Cygwin::posix_to_win_path($bash_dir);
X
X    # Prepare a temporary file to store environment
X    my $tmp_env_handle   = File::Temp->new();
X    my $tmp_env_filename = "$tmp_env_handle";
X    # Close the temporary file handle to avoid 'text file is busy' errors
X    close($tmp_env_handle);
X
X    # Write .bat to a temporary file
X    my $tmp_bat_handle = File::Temp->new(SUFFIX => '.bat');
X    my $tmp_bat        = "$tmp_bat_handle";
X    my $tmp_bat_win    = Cygwin::posix_to_win_path($tmp_bat);
X    my $tmp_bat_dir    = File::Basename::dirname($tmp_bat);
X    # Close the temporary file handle to avoid 'text file is busy' errors
X    close($tmp_bat_handle);
X
X    # Compute parameters
X    my $vcvarsall_params = join(' ', @{$vcvarsall_args});
X
X    open(my $fh, '>', $tmp_bat) or
X        Carp::croak("Unable to create batch file");
X    print $fh <<BATCH;
\@ECHO OFF
CD "$bat_dir_win"
CALL "${bat_path_win}" $vcvarsall_params
CD "$bash_dir_win"
bash -c "perl -MStorable -e 'Cygwin::sync_winenv();' -e 'Storable::store \\%%ENV, \\\"$tmp_env_filename\\\";'"
BATCH
X    chmod 0755, $tmp_bat;
X    chdir $tmp_bat_dir;
X    print "Executing: '${tmp_bat}' or '${tmp_bat_win}'\n";
X    # Add MSYS2_ARG_CONV_EXCL=* to the environment to prevent the '/C'
X    # argument to be converted to 'C:\' by msys2.
X    $ENV{'MSYS2_ARG_CONV_EXCL'}='*';
X    system $comspec_path, '/C', $tmp_bat_win;
X
X    # Read modified environment
X    my %vc_env = %{Storable::retrieve($tmp_env_filename)};
X
X    # Check for errors
X    Carp::croak("Error during setup of VC++ environment")
X        if(! exists($vc_env{VSCMD_VER}) || $vc_env{VSCMD_VER} eq '');
X
X    # Start subshell with modified environment
X    %ENV = %vc_env;
X    # Restore the original value of MSYS2_ARG_CONV_EXCL
X    if (exists($saved_ENV{'MSYS2_ARG_CONV_EXCL'})) {
X        $ENV{'MSYS2_ARG_CONV_EXCL'}=$saved_ENV{'MSYS2_ARG_CONV_EXCL'};
X    }
X    else {
X        delete $ENV{'MSYS2_ARG_CONV_EXCL'};
X    }
X    $ENV{PWD} = $cwd;
X    $ENV{OLDPWD} = $cwd;
X    $ENV{VS_KIT}=join('-', 'msvc', $vc_env{VSCMD_VER}, @{$vcvarsall_args});
X    chdir $cwd;
X    system 'bash', '-i';
X
X    # Restore saved environment
X    chdir $cwd;
X    %ENV = %saved_ENV;
}
X
sub get_default_vs_paths {
X    my @default_vs_paths = ();
X    push(@default_vs_paths, $ENV{'ProgramW6432'})
X        if(exists($ENV{'ProgramW6432'}));
X    push(@default_vs_paths, $ENV{'ProgramFiles(x86)'})
X        if(exists($ENV{'ProgramFiles(x86)'}));
X    @default_vs_paths = map { Cygwin::win_to_posix_path($_) } @default_vs_paths;
X    @default_vs_paths = map { $_.'/Microsoft Visual Studio' } @default_vs_paths;
X    @default_vs_paths = map { my $year=$_; map { $_.'/'.$year } @default_vs_paths; } (18, 2022, 2019, 2017);
X    @default_vs_paths = map { $_.'/Community', $_.'/Professional', $_.'/Enterprise' } @default_vs_paths;
X    @default_vs_paths = map { $_.'/VC/Auxiliary/Build/vcvarsall.bat' } @default_vs_paths;
X    return @default_vs_paths;
}
X
# Load the full windows environment
Cygwin::sync_winenv();
X
# Parse options
my ($opt_help, $opt_p);
Getopt::Long::Configure("no_ignore_case");
Getopt::Long::GetOptionsFromArray(
X    \@ARGV,
X    'help|h'             => \$opt_help,
X    'p|vcvarsall-path=s' => \$opt_p,
) or Carp::croak('Error parsing command line arguments');
X
# Handle help option
if($opt_help) {
X    require Pod::Usage;
X    Pod::Usage::pod2usage(-exitval => 0);
}
X
# Clean '-p' option
$opt_p = Cygwin::win_to_posix_path($opt_p)
X    if(defined($opt_p));
if(! defined($opt_p)) {
X    my @default_vs_paths = get_default_vs_paths();
X    my @found_vcvars = grep { -f $_ } @default_vs_paths;
X    if(@found_vcvars) {
X        $opt_p = $found_vcvars[0];
X        print "Using 'vcvarsall.bat' found in path: ".File::Basename::dirname($opt_p)."\n";
X    }
}
if(! defined($opt_p)) {
X    print STDERR "Unable to find a suitable path to 'vcvarsall.bat'. Please use option '-p'\n";
X    require Pod::Usage;
X    Pod::Usage::pod2usage(-exitval => 1);
}
if(! -f $opt_p) {
X    print STDERR "The path specified by option '-p' is not valid.\n";
X    require Pod::Usage;
X    Pod::Usage::pod2usage(-exitval => 1);
}
X
call_vcvarsall({
X    vcvarsall_bat_path => $opt_p,
X    args => \@ARGV,
});
X
X
__END__
=head1 NAME
X
msvc-shell - MS-VC++ build environment shell spawner
X
=head1 SYNOPSIS
X
B<msvc-shell> B<-h>|B<--help>
X
B<msvc-shell> [B<OPTIONS>] B<VC_OPTIONS>
X
=head1 DESCRIPTION
X
This tool wraps the B<vcvarsall.bat> batch script provided with visual studio
to setup the build environment. Calling this script allows to spawn a shell
with the same configuration that B<vcvarsall.bat> setup when called in a
windows console.
X
The tool also setup a B<VS_KIT> environment variable in the spawned shell to
indicate the parameters that were passed to B<vcvarsall.bat>.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-p> I<path/to/vcvarsall.bat>|B<--vcvarsall-path>=I<path/to/vcvarsall.bat>
X
Sets the path to the B<vcvarsall.bat> batch script. Before Visual Studio 2017
it was possible to deduce the path to this script from the environment variable
set at install time, but this is no longer the case.
X
=back
X
=head1 VC_OPTIONS
X
The B<vcvarsall.bat> script accepts parameters to indicate which architecture,
platform, SDK, etc. is targeted by the environment it sets up.
X
Run the script without B<VC_OPTIONS> to get more information in the error
message printed by B<vcvarsall.bat>.
X
=head1 SEE ALSO
X
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2017-2026 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the GPL license.
X
=cut
X
SHAR_EOF
  (set 20 26 02 15 13 10 07 'scripts/msvc-shell'
   eval "${shar_touch}") && \
  chmod 0764 'scripts/msvc-shell'
if test $? -ne 0
then ${echo} "restore of scripts/msvc-shell failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/msvc-shell': 'MD5 check failed'
       ) << \SHAR_EOF
2bb14755a2096d82dc6861149b134774  scripts/msvc-shell
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/msvc-shell'` -ne 8007 && \
  ${echo} "restoration warning:  size of 'scripts/msvc-shell' is not 8007"
  fi
fi
# ============= scripts/plgen ==============
if test -n "${keep_file}" && test -f 'scripts/plgen'
then
${echo} "x - SKIPPING scripts/plgen (file already exists)"

else
${echo} "x - extracting scripts/plgen (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/plgen' &&
#!/usr/bin/env perl
#*===========================================================================*
#*                                                                           *
#*  plgen - Generate perl plain-old-data record modules
#*                                                                           *
#*  Copyright (c) 2019 Frederic Jardon  <frederic.jardon@gmail.com>          *
#*                                                                           *
#*  ------------------ GPL Licensed Source Code ------------------           *
#*  Frederic Jardon makes this software available under the GNU              *
#*  General Public License (GPL) license for open source projects.           *
#*  For details of the GPL license please see www.gnu.org or read            *
#*  the file license.gpl provided in this package.                           *
#*                                                                           *
#*  This program is free software; you can redistribute it and/or            *
#*  modify it under the terms of the GNU General Public License as           *
#*  published by the Free Software Foundation; either version 3 of           *
#*  the License, or (at your option) any later version.                      *
#*                                                                           *
#*  This program is distributed in the hope that it will be useful,          *
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
#*  GNU General Public License for more details.                             *
#*                                                                           *
#*  You should have received a copy of the GNU General Public                *
#*  License along with this program in the file 'license.gpl'; if            *
#*  not, see <http://www.gnu.org/licenses/>.                                 *
#*  --------------------------------------------------------------           *
#*===========================================================================*
X
use strict;
use warnings 'all';
X
use Carp;
use Data::Dumper;
use File::Basename;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case pass_through);
use Pod::Usage;
use SelectSaver;
X
main() unless caller;
X
sub generate_field_ctor_for_array {
X    my ($field) = @_;
X    my $pl_name = $field->{'pl_name'};
X    my $value   = $field->{'value'} // 'undef';
X
X    my $codegen =<<"CODEGEN";
X        '${pl_name}' => $value,
CODEGEN
X    return $codegen;
}
X
sub generate_field_methods_for_array {
X    my ($field) = @_;
X    my $name      = $field->{'name'};
X    my $pl_name   = $field->{'pl_name'};
X    my $item_type = $field->{'item_type'} // "'undefined'";
X
X    my $codegen =<<"CODEGEN";
X
# Field: ${name} methods
# ------
sub count_${pl_name} {
X    my (\$self) = \@_;
X    return scalar \@{ \$self->{'_${pl_name}'} };
}
X
sub get_${pl_name} {
X    my (\$self) = \@_;
X    return \@{ \$self->{'_${pl_name}'} };
}
X
sub set_${pl_name} {
X    my (\$self, \@new_values) = \@_;
X    \@{ \$self->{'_${pl_name}'} } = (\@new_values);
}
X
sub push_${pl_name} {
X    my (\$self, \@new_values) = \@_;
X    push(\@{ \$self->{'_${pl_name}'} }, \@new_values);
}
X
sub clear_${pl_name} {
X    my (\$self) = \@_;
X    \@{ \$self->{'_${pl_name}'} } = ();
}
X
sub apply_${pl_name} {
X    my (\$self, \$sub) = \@_;
X    map { \$sub->(\$_) } \@{ \$self->{'_${pl_name}'} };
}
CODEGEN
X    return $codegen;
}
X
sub generate_field_methods_for_scalar {
X    my ($field) = @_;
X    my $name      = $field->{'name'};
X    my $item_type = $field->{'item_type'} // "'undefined'";
X    my $pl_name   = $field->{'pl_name'};
X
X    my $codegen =<<"CODEGEN";
X
# Field: ${name} methods
# ------
sub get_${pl_name} {
X    my (\$self) = \@_;
X    return \$self->{'_${pl_name}'};
}
X
sub set_${pl_name} {
X    my (\$self, \$new_value) = \@_;
X    \$self->{'_${pl_name}'} = \$new_value;
}
CODEGEN
X    return $codegen;
}
X
sub generate_field_pod_for_array {
X    my ($field) = @_;
X    my $name      = $field->{'name'};
X    my $pl_name   = $field->{'pl_name'};
X    my $item_type = $field->{'item_type'} // "'undefined'";
X
X    my $codegen =<<"CODEGEN";
X
#=item count_field_name()
X
Returns the count of elements in the array
X
#=item get_field_name()
X
Which returns a list
X
#=item set_field_name(I<\@new_values>)
X
Which copies the items in the internal array
X
#=item push_field_name(I<\@new_values>)
X
Which append items to the internal array
X
#=item clear_field_name()
X
Which clears the internal array
X
#=item apply_field_name(I<sub {...}>)
X
Which applies the sub on the array's items
CODEGEN
X    return $codegen;
}
X
sub generate_field_pod_for_scalar {
X    my ($field) = @_;
X    my $name      = $field->{'name'};
X    my $item_type = $field->{'item_type'} // "'undefined'";
X    my $pl_name   = $field->{'pl_name'};
X
X    my $codegen =<<"CODEGEN";
X
#=item get_${pl_name}()
X
Gets the scalar value of the field.
X
#=item set_${pl_name}(I<\$new_value>)
X
Sets the scalar value of the new field.
CODEGEN
X    return $codegen;
}
X
sub generate_header {
X    my ($parameters_ref) = @_;
X    my $filename   = basename $parameters_ref->{'filename'};
X    my $version    = $parameters_ref->{'version'};
X    my $class_name = $parameters_ref->{'class_name'};
X    my @fields     = @{ $parameters_ref->{'fields'} };
X    my $codegen =<<"CODEGEN";
#!/usr/bin/env perl
#*===========================================================================*
#*                                                                           *
#*  ${filename} - A perl plain-old-data record modules
#*                                                                           *
#*  Copyright (c) 2019 Frederic Jardon  <frederic.jardon\@gmail.com>          *
#*                                                                           *
#*  ------------------ GPL Licensed Source Code ------------------           *
#*  Frederic Jardon makes this software available under the GNU              *
#*  General Public License (GPL) license for open source projects.           *
#*  For details of the GPL license please see www.gnu.org or read            *
#*  the file license.gpl provided in this package.                           *
#*                                                                           *
#*  This program is free software; you can redistribute it and/or            *
#*  modify it under the terms of the GNU General Public License as           *
#*  published by the Free Software Foundation; either version 3 of           *
#*  the License, or (at your option) any later version.                      *
#*                                                                           *
#*  This program is distributed in the hope that it will be useful,          *
#*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
#*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
#*  GNU General Public License for more details.                             *
#*                                                                           *
#*  You should have received a copy of the GNU General Public                *
#*  License along with this program in the file 'license.gpl'; if            *
#*  not, see <http://www.gnu.org/licenses/>.                                 *
#*  --------------------------------------------------------------           *
#*===========================================================================*
package ${class_name};
X
use strict;
use warnings 'all';
X
require Exporter;
X
our \@ISA = qw(Exporter);
X
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
X
# This allows declaration	use ${class_name} ':all';
# If you do not need this, moving things directly into \@EXPORT or \@EXPORT_OK
# will save memory.
our \%EXPORT_TAGS = ( 'all' => [ qw(
X
) ] );
X
our \@EXPORT_OK = ( \@{ \$EXPORT_TAGS{'all'} } );
X
our \@EXPORT = qw(
X
);
X
our \$VERSION = '${version}';
X
# Preloaded methods go here.
#
sub new {
X    my (\$class, \$parameters_ref) = \@_;
X    my \$self = {
X @{[ map { generate_field_ctor_for_array($_) } @fields ]}
X    };
X    return bless \$self, \$class;
}
CODEGEN
X    return $codegen;
}
X
sub generate_footer {
X    my ($parameters_ref) = @_;
X    my $filename   = basename $parameters_ref->{'filename'};
X    my $version    = $parameters_ref->{'version'};
X    my $class_name = $parameters_ref->{'class_name'};
X    my @fields     = @{ $parameters_ref->{'fields'} };
X
X    my $pod_generator_for_field_type_ref = {
X        'array'  => \&generate_field_pod_for_array,
X        'scalar' => \&generate_field_pod_for_scalar,
X    };
X
X    my $codegen =<<"CODEGEN";
X
if(!caller) {
X    use Test::More;
X    ok(1);
X    done_testing;
}
X
1;
X
#__END__
X
#=head1 NAME
X
${class_name} - Plain Old Perl Data Record
X
#=head1 VERSION
X
This documentation refers to ${class_name} version ${version}.
X
#=head1 SYNOPSIS
X
X    use ${class_name};
X
X    my \$record = ${class_name}->new();
X
#=head1 DESCRIPTION
X
This module implements a plain old data record.
X
#=head1 SUBROUTINES/METHODS
X
#=over 5
X
@{[ map { $pod_generator_for_field_type_ref->{$_->{'type'}}->($_) } @fields ]}
X
#=back
X
#=head1 DIAGNOSTICS
X
none
X
#=head1 CONFIGURATION AND ENVIRONMENT
X
none
X
#=head1 DEPENDENCES
X
none
X
#=head1 INCOMPATIBILITIES
X
none
X
#=head1 BUGS AND LIMITATIONS
X
none
X
#=head1 SEE ALSO
X
X
#=head1 AUTHOR
X
Frederic JARDON <frederic.jardon\@gmail.com>
X
#=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2020 by Frederic JARDON <frederic.jardon\@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the GPL license.
X
#=cut
X
CODEGEN
X    return $codegen;
}
X
X
#=item get_options({ argv => \@ARGV, env => \%env })
#
#Returns a HASH reference whose keys are the parsed options.
#
#- input, the input filename
#- output, the output filename
#
#=cut
sub get_options {
X    my ($parameters_ref) = @_;
X    my $argv = $parameters_ref->{'argv'};
X    my ($opt_help, $opt_c, $opt_o,);
X
X    GetOptionsFromArray($argv,
X        'h|help' => \$opt_help,
X        'c=s'    => \$opt_c,
X        'o=s'    => \$opt_o,
X    ) or croak "Error while parsing command-line arguments";
X
X    # Handle help option
X    pod2usage(-exitval => 0) if ($opt_help);
X
X    $opt_c //= '-';
X    $opt_o //= '-';
X
X    if(@{$argv}) {
X        print STDERR "Extra arguments on command line\n";
X        pod2usage(-exitval => 1);
X    }
X
X    my $opts = {
X        'input'  => $opt_c,
X        'output' => $opt_o,
X    };
X    return $opts;
}
X
#=item read_input_file({filename => $filename})
#
#Returns a HASH reference whose keys are:
#
#- class_name: the class name defined in the input file
#- version:    the version defined in the input file
#- fields:     an ARRAY reference containing field descriptions
#
#Each field description is a HASH reference whose keys are:
#
#- name:      the name of the field as defined in the input file
#- pl_name:   the name of the field converted to a suitable perl identifier
#- type:      one of: array, hash, scalar
#- item_type: the type of items stored in the array if the field is an array
#- value:     the initial value of the field
#
#=cut
sub read_input_file {
X    my ($parameters_ref) = @_;
X
X    my $filename = $parameters_ref->{'filename'};
X    croak "Missing parameter 'filename'" if(!defined($filename));
X
X    my ($class_name, $version);
X    my @fields = ();
X
X    my $in_fh = \*STDIN;
X    if($filename ne '-') {
X        open(my $in, '<', $filename)
X            or croak("Unable to open: '$filename' for reading");
X        $in_fh = $in;
X    }
X    while(my $line = <$in_fh>) {
X        # Remove leading and trailing spaces
X        chomp $line;
X        $line =~ s/^\s+//g;
X
X        # Remove comments and blank lines
X        next if('' eq $line or $line =~ m/^#/);
X
X        # Handle the ':class-name:' attribute
X        if($line =~ m/^:class-name:\s*([a-zA-Z0-9_:]+)$/) {
X            $class_name = $1;
X            next;
X        }
X
X        # Handle the ':version:' attribute
X        if($line =~ m/^:version:\s*([a-zA-Z0-9_.-]+)$/) {
X            $version = $1;
X            next;
X        }
X
X        # Handle field
X        my $field_line = $line;
X        if($field_line =~ s/^(\S+)\s+//g) {
X            my $field = { 'name' => $1 };
X            if($field_line =~ s/\s+([a-zA-Z0-9_:]+)$//g) {
X                $field->{ 'item_type' } = $1;
X            }
X
X            $field->{ 'value' } = $field_line;
X            if($field->{ 'value' } ne '') {
X                $field->{ 'type' }   = 'array' if($field->{'value'} =~ m/^\[/);
X                $field->{ 'type' } //= 'scalar';
X                push(@fields, $field);
X                next;
X            }
X
X            print STDERR "Unknown field definition: '$line'\n";
X        }
X
X        # Erroneous line
X        print STDERR "Unknown line format: '$line'\n";
X    }
X    close($in_fh)
X        if($filename ne '-');
X
X    foreach my $field (@fields) {
X        my $pl_name = $field->{'name'};
X        $pl_name =~ s/[^\w\d]/_/g;
X        $field->{'pl_name'} = $pl_name;
X    }
X
X    my $spec_ref = {
X        'class_name' => $class_name // 'Plain::Old::Data',
X        'version'    => $version    // '0.01',
X        'fields'     => \@fields,
X    };
X    return $spec_ref;
}
X
#=item generate_output({filename => $filename, class_name => '...', fields => [...]})
#
#Generate the output file whose fields are described by I<fields>.
#
#=cut
sub generate_output {
X    my ($parameters_ref) = @_;
X    my $class_name = $parameters_ref->{'class_name'};
X    my $fields_ref = $parameters_ref->{'fields'};
X    my $filename   = $parameters_ref->{'filename'};
X    croak "Missing parameter 'class_name'" if(!defined($class_name));
X    croak "Missing parameter 'fields'"     if(!defined($fields_ref));
X    croak "Missing parameter 'filename'"   if(!defined($filename));
X    my @fields = @{ $fields_ref };
X
X    my $method_generators = {
X        'array'  => \&generate_field_methods_for_array,
X        'scalar' => \&generate_field_methods_for_scalar,
X    };
X
X    my $codegen =<<"CODEGEN";
${\( generate_header($parameters_ref) )}
@{[ map { $method_generators->{$_->{'type'}}->($_) } @fields ]}
${\( generate_footer($parameters_ref) )}
CODEGEN
X
X    # Transform the escaped pod and __END__ macros
X    $codegen =~ s/^#=/=/mg;
X    $codegen =~ s/^#__END__/__END__/mg;
X    # Trim whitespaces at end of line
X    $codegen =~ s/\s+$/\n/mg;
X
X    my $out_fh = \*STDOUT;
X    if($filename ne '-') {
X        open(my $out, '>', $filename)
X            or croak("Unable to open: '$filename' for writing");
X        $out_fh = $out;
X    }
X    {
X        my $saver = SelectSaver->new($out_fh);
X        print $codegen;
X    }
X    close($out_fh)
X        if($filename ne '-');
X
X    return;
}
X
sub main {
X    my $opts = get_options({argv => \@ARGV, env => \%ENV});
X    my $spec = read_input_file({filename => $opts->{'input'}});
X    generate_output({'filename' => $opts->{'output'}, %{$spec}});
}
X
__END__
=head1 NAME
X
plgen - Code Formatter tool
X
=head1 SYNOPSIS
X
B<plgen> B<-h>|B<--help>
X
B<plgen> [B<OPTIONS>] -c B<FILE>
X
=head1 DESCRIPTION
X
This tool format tabular data into fixed size columns.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-c> I<FILE>
X
Sets the input file to compile.
X
=item B<-o> I<OUTPUT>
X
Sets the output file to generate.
X
=back
X
=head1 INPUT FILE FORMAT
X
The input file describe a simple data record. The file format is line oriented
and should start with a header:
X
X    :class-name: The::Class::Name
X    :version: 0.0.2a
X    # Some comment
X    #
X    # Field       Default-Value   Item-Type_opt
X    field-name-1  ''
X    field-name-2  []              Item::Type
X    field-name-3  0
X
The following methods are created for scalar fields:
X
=over 5
X
=item get_field_name()
X
Gets the scalar value of the field.
X
=item set_field_name(I<$new_value>)
X
Sets the scalar value of the new field.
X
=back
X
For array fields, the following methods are created:
X
=over 5
X
=item count_field_name()
X
Returns the count of elements in the array.
X
=item get_field_name()
X
Which returns a list.
X
=item set_field_name(I<@new_values>)
X
Which copies the items in the internal array.
X
=item push_field_name(I<@new_values>)
X
Which append items to the internal array.
X
=item clear_field_name()
X
Which clears the internal array.
X
=item apply_field_name(I<sub {...}>)
X
Which applies the sub on the array's items.
X
=back
X
X
=head1 DIAGNOSTICS
X
=head1 CONFIGURATION AND ENVIRONMENT
X
=head1 DEPENDENCIES
X
=head1 INCOMPATIBILITIES
X
=head1 BUGS AND LIMITATIONS
X
=head1 SEE ALSO
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2019 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the GPL license.
X
=cut
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/plgen'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/plgen'
if test $? -ne 0
then ${echo} "restore of scripts/plgen failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/plgen': 'MD5 check failed'
       ) << \SHAR_EOF
4c0548f326d9f5060c786e6fc0f7195a  scripts/plgen
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/plgen'` -ne 16939 && \
  ${echo} "restoration warning:  size of 'scripts/plgen' is not 16939"
  fi
fi
# ============= scripts/runcron ==============
if test -n "${keep_file}" && test -f 'scripts/runcron'
then
${echo} "x - SKIPPING scripts/runcron (file already exists)"

else
${echo} "x - extracting scripts/runcron (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/runcron' &&
#!/usr/bin/env bash
X
# Exit on any errors
set -e
X
# A function to output on stderr
function echoerr() { echo "$@" 1>&2; }
X
# Configuration
CRONDIR=~/.local/etc/cron
X
# Get this script name
script="$0"
X
# Sanity check
scriptdir="$1"
if [ -z "${scriptdir}" ]; then
X    echoerr "Usage: ${script} <directory>"
X    echoerr ""
X    echoerr "Run all scripts inside a directory."
X    exit 1
fi
X
SCRIPTDIR="${CRONDIR}/${scriptdir}"
if [ ! -d "${SCRIPTDIR}" ]; then
X    echoerr "Directory: '${SCRIPTDIR}' doesn't exist. ABORTING!"
X    exit 1
fi
X
X
# Load custom cron environment if present
if [ -e "${CRONDIR}/environ.bash" ]; then
X    source "${CRONDIR}/environ.bash"
fi
X
# Run the commands
for script in "${SCRIPTDIR}"/*
do
X    if [ -f "${script}" -a -x "${script}" ]; then
X        echo "Running script: '${script}' ..."
X        echo "---------------"
X        ( "${script}" )
X        echo -e "\f"
X    fi
done
X
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/runcron'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/runcron'
if test $? -ne 0
then ${echo} "restore of scripts/runcron failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/runcron': 'MD5 check failed'
       ) << \SHAR_EOF
0b2ab5f23034f9404b7dcff31ae0e52a  scripts/runcron
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/runcron'` -ne 901 && \
  ${echo} "restoration warning:  size of 'scripts/runcron' is not 901"
  fi
fi
# ============= scripts/sixel2tmux ==============
if test -n "${keep_file}" && test -f 'scripts/sixel2tmux'
then
${echo} "x - SKIPPING scripts/sixel2tmux (file already exists)"

else
${echo} "x - extracting scripts/sixel2tmux (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/sixel2tmux' &&
#!/usr/bin/env perl
X
use strict;
use warnings 'all';
X
use Carp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case);
use Pod::Usage;
X
sub tmux_dcs_escape {
X    my ($inception_level, $msg) = @_;
X
X    for(my $l=0; $l<$inception_level; ++$l) {
X        my $dcs_payload = $msg;
X        $dcs_payload =~ s/\033/\033\033/g;
X        $msg = "\033Ptmux;$dcs_payload\033\\";
X    }
X    return $msg;
}
X
# Parse options
my ($opt_help, $opt_t, $opt_tmux_tty, $opt_l);
GetOptionsFromArray(
X    \@ARGV,
X    'help|h'              => \$opt_help,
X    'l|inception-level=s' => \$opt_l,
X    't|terminal=s'        => \$opt_t,
) or croak('Error parsing command line arguments');
X
# Handle help option
pod2usage(-exitval => 0) if $opt_help;
X
# get terminal
my ($terminal);
$terminal //= $opt_t if(defined($opt_t));
$terminal //= '/dev/tty';
X
# inception level
$opt_l //= 1 if(exists($ENV{'TMUX'}));
$opt_l //= 0;
X
# output to tty
my $tty;
$tty = \*STDOUT;
open($tty, '>', $terminal) or croak("Unable to open tty: $terminal\n") if('-' ne $terminal);
X
# loop reading sixel chunks, escape them using tmux DCS and loop again
my ($msg, $payload, $chunk) = ('', '', '');
my $max_byte_size = 74994;
binmode STDIN;
binmode $tty;
while(sysread STDIN, $msg, 256) {
X    $payload .= $msg;
X    while($payload =~ s/^((.*)?\e\\)//g) {
X        $chunk = $1;
X        $chunk = tmux_dcs_escape($opt_l, $chunk);
X        if(length($chunk) > $max_byte_size) {
X            print STDERR "An escape sequence is too large to pass-through: ".length($chunk)." > $max_byte_size. Aborting!\n";
X            exit 1;
X        }
X        syswrite $tty, $chunk;
X    }
}
$chunk = tmux_dcs_escape($opt_l, $payload);
syswrite $tty, $chunk;
close($tty) if('-' ne $terminal);
X
__END__
=head1 NAME
X
sixel2tmux - Script converting sixel input into tmux's DCS escape sequence
X
=head1 SYNOPSIS
X
B<sixel2tmux> B<-h>|B<--help>
X
B<sixel2tmux> [B<OPTIONS>]
X
GNUTERM=sixelgd gnuplot -e 'plot sin(x)' | B<sixel2tmux>
X
=head1 DESCRIPTION
X
This tool converts standard input into a I<tmux> specific B<DCS> escape sequence
and outputs it to a terminal.
X
The output of the program should be directed to a terminal. In case no terminal
is specified, the script will use F</dev/tty>.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-t> I<TERMINAL>|B<--terminal>=I<TERMINAL>
X
Sets the terminal used to output the tmux DCS escape sequence. In case the
terminal is not specified, the default value is: F</dev/tty>.
X
The special name: '-' means I<stdout>
X
=item B<-l>=I<INCEPTION>|B<--inception-level>=I<INCEPTION>
X
Sets the B<tmux> inception level. This is needed in case you connect to another
B<tmux> session from within a B<tmux> session. Default value is 0 unless the
B<TMUX> environment variable is set, in which case the default value is 1.
X
=back
X
X
=head1 ENVIRONMENT VARIABLES
X
=over
X
=item TMUX
X
The B<TMUX> environment variable is used to find out if we are running inside
a B<tmux> pane.
X
=back
X
X
=head1 SEE ALSO
X
xterm(1), tmux(1)
X
=over
X
=item I<XTerm Control Sequences>
X
X    https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Operating-System-Commands
X
=item I<Device Control String Sequences>
X
X    https://vt100.net/docs/vt510-rm/chapter4.html
X
=item I<TMux DCS Sequences>
X
X    see tmux changelog
X
=back
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2017 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the MIT license.
X
=cut
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/sixel2tmux'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/sixel2tmux'
if test $? -ne 0
then ${echo} "restore of scripts/sixel2tmux failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/sixel2tmux': 'MD5 check failed'
       ) << \SHAR_EOF
1502bceaaa5049181d318128b8e4d58d  scripts/sixel2tmux
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/sixel2tmux'` -ne 3591 && \
  ${echo} "restoration warning:  size of 'scripts/sixel2tmux' is not 3591"
  fi
fi
# ============= scripts/uudecode.pl ==============
if test -n "${keep_file}" && test -f 'scripts/uudecode.pl'
then
${echo} "x - SKIPPING scripts/uudecode.pl (file already exists)"

else
${echo} "x - extracting scripts/uudecode.pl (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/uudecode.pl' &&
#!/usr/bin/env perl
X
$_=<>;
m/^begin ([0-7]+) (.+)$/ or die("Unable to find header");
my ($mode,$filename) = (oct($1), $2);
X
open(my $fh, '>', $filename) or die("Unable to open: '$filename'");
binmode $fh;
while($_=<>) {
X    last if m/^end$/;
X    my $out = unpack 'u*', $_;
X    print $fh $out;
}
close($fh);
chmod $mode, $filename;
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/uudecode.pl'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/uudecode.pl'
if test $? -ne 0
then ${echo} "restore of scripts/uudecode.pl failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/uudecode.pl': 'MD5 check failed'
       ) << \SHAR_EOF
8cc88c63f51338cd0ff71f04d846ac3a  scripts/uudecode.pl
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/uudecode.pl'` -ne 332 && \
  ${echo} "restoration warning:  size of 'scripts/uudecode.pl' is not 332"
  fi
fi
# ============= scripts/yank ==============
if test -n "${keep_file}" && test -f 'scripts/yank'
then
${echo} "x - SKIPPING scripts/yank (file already exists)"

else
${echo} "x - extracting scripts/yank (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/yank' &&
#!/usr/bin/env perl
X
use strict;
use warnings 'all';
X
use Carp;
use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case);
use MIME::Base64 qw(encode_base64);
use Pod::Usage;
X
sub get_tmux_tty {
X    my $pty = `tmux list-panes -F "#{pane_tty}"`;
X    return undef if($?);
X    return $pty;
}
X
# Parse options
my ($opt_help, $opt_t, $opt_tmux_tty, $opt_l);
GetOptionsFromArray(
X    \@ARGV,
X    'help|h'       => \$opt_help,
X    'l|inception-level=s' => \$opt_l,
X    't|terminal=s' => \$opt_t,
X    'tmux-tty'     => \$opt_tmux_tty,
) or croak('Error parsing command line arguments');
X
# Handle help option
pod2usage(-exitval => 0) if $opt_help;
X
# get terminal
my ($terminal);
$terminal //= get_tmux_tty if(defined($opt_tmux_tty));
$terminal //= $opt_t if(defined($opt_t));
$terminal //= '/dev/tty';
X
# inception level
$opt_l //= 1 if(exists($ENV{'TMUX'}));
$opt_l //= 0;
X
# read input
my $max_byte_size = 74994;
my $msg = '';
while(length($msg) < $max_byte_size) {
X    my $line = <STDIN>;
X    last if(!defined($line));
X    $msg = $msg.$line;
}
croak('Error: message is too big')
X    if(length($msg) > $max_byte_size);
my ($b64, $osc52);
$b64   = encode_base64($msg);
$b64   =~ s/[\r\n]//g;
X
# OSC 5-2 is to modify the operating system selection (copy/paste buffer)
$osc52 = "\033]52;c;$b64\a";
X
# In case we are incepted in TMUX, use a tmux specific DCS to pass the OSC to
# the outer tty
for(my $l=0; $l<$opt_l; ++$l) {
X    my $dcs_payload = $osc52;
X    $dcs_payload =~ s/\033/\033\033/g;
X    $osc52 = "\033Ptmux;$dcs_payload\033\\";
}
X
# output to tty
open(my $tty, '>', $terminal) or croak("Unable to open tty: $terminal\n");
print $tty $osc52;
close($tty);
X
__END__
=head1 NAME
X
yank - Script converting input into OSC 5-2 escape sequence
X
=head1 SYNOPSIS
X
B<yank> B<-h>|B<--help>
X
B<yank> [B<OPTIONS>]
X
echo "Text To Copy" | B<yank>
X
=head1 DESCRIPTION
X
This tool converts standard input into B<OSC 5-2> escape sequence and outputs
it to a terminal. These escape sequences are interpreted by terminals to set
their B<selection> buffer. For B<XTerm> it means the B<X11> copy/paste buffer.
X
The script can used to provide seamless copy/paste capabilities between a host
and a remote session. For instance a user running B<vim> through B<tmux> on a
remote host connected by B<ssh> running on its B<Windows> laptop.
X
The output of the program should be directed to a terminal. In case no terminal
is specified, the script will use F</dev/tty>.
X
=head1 OPTIONS
X
=over
X
=item B<-h>|B<--help>
X
Print the usage, help and version information for this program and exit.
X
=item B<-t> I<TERMINAL>|B<--terminal>=I<TERMINAL>
X
Sets the terminal used to output the OSC 5-2 escape sequence. In case the
terminal is not specified, the default value is: F</dev/tty>.
X
=item B<--tmux-tty>
X
Sets the terminal used to output the OSC 5-2 escape sequence to the B<tmux> pane
tty. In case the program is unable to find out B<tmux> pane's tty, the value of
the B<--terminal> option is taken into account.
X
=item B<-l>=I<INCEPTION>|B<--inception-level>=I<INCEPTION>
X
Sets the B<tmux> inception level. This is needed in case you connect to another
B<tmux> session from within a B<tmux> session. Default value is 0 unless the
B<TMUX> environment variable is set, in which case the default value is 1.
X
=back
X
=head1 LIMITATIONS
X
No more than 74994 bytes of data can be transmitted through the OSC 5-2 escape
sequence.
X
=head1 ENVIRONMENT VARIABLES
X
=over
X
=item TMUX
X
The B<TMUX> environment variable is used to find out if we are running inside
a B<tmux> pane.
X
=back
X
X
=head1 SEE ALSO
X
xterm(1), tmux(1)
X
=over
X
=item I<XTerm Control Sequences>
X
X    https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Operating-System-Commands
X
=item I<Device Control String Sequences>
X
X    https://vt100.net/docs/vt510-rm/chapter4.html
X
=item I<TMux DCS Sequences>
X
X    see tmux changelog
X
=back
X
=head1 AUTHOR
X
Frederic JARDON <frederic.jardon@gmail.com>
X
=head1 COPYRIGHT AND LICENSE
X
Copyright (C) 2017 by Frederic JARDON <frederic.jardon@gmail.com>
X
This program is free software; you can redistribute it and/or modify
it under the MIT license.
X
=cut
X
SHAR_EOF
  (set 20 25 12 31 14 16 58 'scripts/yank'
   eval "${shar_touch}") && \
  chmod 0770 'scripts/yank'
if test $? -ne 0
then ${echo} "restore of scripts/yank failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/yank': 'MD5 check failed'
       ) << \SHAR_EOF
b5528cfbfa7966be5377b78960cd2e28  scripts/yank
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/yank'` -ne 4128 && \
  ${echo} "restoration warning:  size of 'scripts/yank' is not 4128"
  fi
fi
# ============= libstdc++-v3/python/libstdcxx/__init__.py ==============
if test ! -d 'libstdc++-v3'; then
  mkdir 'libstdc++-v3'
if test $? -eq 0
then ${echo} "x - created directory libstdc++-v3."
else ${echo} "x - failed to create directory libstdc++-v3."
     exit 1
fi
fi
if test ! -d 'libstdc++-v3/python'; then
  mkdir 'libstdc++-v3/python'
if test $? -eq 0
then ${echo} "x - created directory libstdc++-v3/python."
else ${echo} "x - failed to create directory libstdc++-v3/python."
     exit 1
fi
fi
if test ! -d 'libstdc++-v3/python/libstdcxx'; then
  mkdir 'libstdc++-v3/python/libstdcxx'
if test $? -eq 0
then ${echo} "x - created directory libstdc++-v3/python/libstdcxx."
else ${echo} "x - failed to create directory libstdc++-v3/python/libstdcxx."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'libstdc++-v3/python/libstdcxx/__init__.py'
then
${echo} "x - SKIPPING libstdc++-v3/python/libstdcxx/__init__.py (file already exists)"

else
${echo} "x - extracting libstdc++-v3/python/libstdcxx/__init__.py (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'libstdc++-v3/python/libstdcxx/__init__.py' &&
X
SHAR_EOF
  (set 20 26 02 15 11 19 12 'libstdc++-v3/python/libstdcxx/__init__.py'
   eval "${shar_touch}") && \
  chmod 0760 'libstdc++-v3/python/libstdcxx/__init__.py'
if test $? -ne 0
then ${echo} "restore of libstdc++-v3/python/libstdcxx/__init__.py failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'libstdc++-v3/python/libstdcxx/__init__.py': 'MD5 check failed'
       ) << \SHAR_EOF
68b329da9893e34099c7d8ad5cb9c940  libstdc++-v3/python/libstdcxx/__init__.py
SHAR_EOF

else
test `LC_ALL=C wc -c < 'libstdc++-v3/python/libstdcxx/__init__.py'` -ne 1 && \
  ${echo} "restoration warning:  size of 'libstdc++-v3/python/libstdcxx/__init__.py' is not 1"
  fi
fi
# ============= libstdc++-v3/python/libstdcxx/v6/__init__.py ==============
if test ! -d 'libstdc++-v3/python/libstdcxx'; then
  mkdir 'libstdc++-v3/python/libstdcxx'
if test $? -eq 0
then ${echo} "x - created directory libstdc++-v3/python/libstdcxx."
else ${echo} "x - failed to create directory libstdc++-v3/python/libstdcxx."
     exit 1
fi
fi
if test ! -d 'libstdc++-v3/python/libstdcxx/v6'; then
  mkdir 'libstdc++-v3/python/libstdcxx/v6'
if test $? -eq 0
then ${echo} "x - created directory libstdc++-v3/python/libstdcxx/v6."
else ${echo} "x - failed to create directory libstdc++-v3/python/libstdcxx/v6."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'libstdc++-v3/python/libstdcxx/v6/__init__.py'
then
${echo} "x - SKIPPING libstdc++-v3/python/libstdcxx/v6/__init__.py (file already exists)"

else
${echo} "x - extracting libstdc++-v3/python/libstdcxx/v6/__init__.py (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'libstdc++-v3/python/libstdcxx/v6/__init__.py' &&
# Copyright (C) 2014-2023 Free Software Foundation, Inc.
X
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
X
# Load the xmethods if GDB supports them.
def gdb_has_xmethods():
X    try:
X        import gdb.xmethod
X        return True
X    except ImportError:
X        return False
X
def register_libstdcxx_printers(obj):
X    # Load the pretty-printers.
X    from .printers import register_libstdcxx_printers
X    register_libstdcxx_printers(obj)
X
X    if gdb_has_xmethods():
X        from .xmethods import register_libstdcxx_xmethods
X        register_libstdcxx_xmethods(obj)
SHAR_EOF
  (set 20 26 02 15 11 19 12 'libstdc++-v3/python/libstdcxx/v6/__init__.py'
   eval "${shar_touch}") && \
  chmod 0760 'libstdc++-v3/python/libstdcxx/v6/__init__.py'
if test $? -ne 0
then ${echo} "restore of libstdc++-v3/python/libstdcxx/v6/__init__.py failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'libstdc++-v3/python/libstdcxx/v6/__init__.py': 'MD5 check failed'
       ) << \SHAR_EOF
74cf87654ab91027b27296333b040171  libstdc++-v3/python/libstdcxx/v6/__init__.py
SHAR_EOF

else
test `LC_ALL=C wc -c < 'libstdc++-v3/python/libstdcxx/v6/__init__.py'` -ne 1149 && \
  ${echo} "restoration warning:  size of 'libstdc++-v3/python/libstdcxx/v6/__init__.py' is not 1149"
  fi
fi
# ============= libstdc++-v3/python/libstdcxx/v6/printers.py ==============
if test ! -d 'libstdc++-v3/python/libstdcxx/v6'; then
  mkdir 'libstdc++-v3/python/libstdcxx/v6'
if test $? -eq 0
then ${echo} "x - created directory libstdc++-v3/python/libstdcxx/v6."
else ${echo} "x - failed to create directory libstdc++-v3/python/libstdcxx/v6."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'libstdc++-v3/python/libstdcxx/v6/printers.py'
then
${echo} "x - SKIPPING libstdc++-v3/python/libstdcxx/v6/printers.py (file already exists)"

else
${echo} "x - extracting libstdc++-v3/python/libstdcxx/v6/printers.py (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'libstdc++-v3/python/libstdcxx/v6/printers.py' &&
# Pretty-printers for libstdc++.
X
# Copyright (C) 2008-2023 Free Software Foundation, Inc.
X
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
X
import gdb
import itertools
import re
import sys
import errno
import datetime
X
# Python 2 + Python 3 compatibility code
X
# Resources about compatibility:
#
#  * <http://pythonhosted.org/six/>: Documentation of the "six" module
X
# FIXME: The handling of e.g. std::basic_string (at least on char)
# probably needs updating to work with Python 3's new string rules.
#
# In particular, Python 3 has a separate type (called byte) for
# bytestrings, and a special b"" syntax for the byte literals; the old
# str() type has been redefined to always store Unicode text.
#
# We probably can't do much about this until this GDB PR is addressed:
# <https://sourceware.org/bugzilla/show_bug.cgi?id=17138>
X
if sys.version_info[0] > 2:
X    # Python 3 stuff
X    Iterator = object
X    # Python 3 folds these into the normal functions.
X    imap = map
X    izip = zip
X    # Also, int subsumes long
X    long = int
X    _utc_timezone = datetime.timezone.utc
else:
X    # Python 2 stuff
X    class Iterator:
X        """Compatibility mixin for iterators
X
X        Instead of writing next() methods for iterators, write
X        __next__() methods and use this mixin to make them work in
X        Python 2 as well as Python 3.
X
X        Idea stolen from the "six" documentation:
X        <http://pythonhosted.org/six/#six.Iterator>
X        """
X
X        def next(self):
X            return self.__next__()
X
X    # In Python 2, we still need these from itertools
X    from itertools import imap, izip
X
X    # Python 2 does not provide the datetime.UTC singleton.
X    class UTC(datetime.tzinfo):
X        """Concrete tzinfo class representing the UTC time zone."""
X
X        def utcoffset(self, dt):
X            return datetime.timedelta(0)
X
X        def tzname(self, dt):
X            return "UTC"
X
X        def dst(self, dt):
X            return datetime.timedelta(0)
X    _utc_timezone = UTC()
X
# Try to use the new-style pretty-printing if available.
_use_gdb_pp = True
try:
X    import gdb.printing
except ImportError:
X    _use_gdb_pp = False
X
# Try to install type-printers.
_use_type_printing = False
try:
X    import gdb.types
X    if hasattr(gdb.types, 'TypePrinter'):
X        _use_type_printing = True
except ImportError:
X    pass
X
# Use the base class if available.
if hasattr(gdb, 'ValuePrinter'):
X    printer_base = gdb.ValuePrinter
else:
X    printer_base = object
X
# Starting with the type ORIG, search for the member type NAME.  This
# handles searching upward through superclasses.  This is needed to
# work around http://sourceware.org/bugzilla/show_bug.cgi?id=13615.
X
X
def find_type(orig, name):
X    typ = orig.strip_typedefs()
X    while True:
X        # Use Type.tag to ignore cv-qualifiers.  PR 67440.
X        search = '%s::%s' % (typ.tag, name)
X        try:
X            return gdb.lookup_type(search)
X        except RuntimeError:
X            pass
X        # The type was not found, so try the superclass.  We only need
X        # to check the first superclass, so we don't bother with
X        # anything fancier here.
X        fields = typ.fields()
X        if len(fields) and fields[0].is_base_class:
X            typ = fields[0].type
X        else:
X            raise ValueError("Cannot find type %s::%s" % (str(orig), name))
X
X
_versioned_namespace = '__8::'
X
X
def lookup_templ_spec(templ, *args):
X    """
X    Lookup template specialization templ<args...>.
X    """
X    t = '{}<{}>'.format(templ, ', '.join([str(a) for a in args]))
X    try:
X        return gdb.lookup_type(t)
X    except gdb.error as e:
X        # Type not found, try again in versioned namespace.
X        global _versioned_namespace
X        if _versioned_namespace not in templ:
X            t = t.replace('::', '::' + _versioned_namespace, 1)
X            try:
X                return gdb.lookup_type(t)
X            except gdb.error:
X                # If that also fails, rethrow the original exception
X                pass
X        raise e
X
# Use this to find container node types instead of find_type,
# see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91997 for details.
def lookup_node_type(nodename, containertype):
X    """
X    Lookup specialization of template nodename corresponding to containertype.
X
X    nodename - The name of a class template, as a String
X    containertype - The container, as a gdb.Type
X
X    Return a gdb.Type for the corresponding specialization of nodename,
X    or None if the type cannot be found.
X
X    e.g. lookup_node_type('_List_node', gdb.lookup_type('std::list<int>'))
X    will return a gdb.Type for the type std::_List_node<int>.
X    """
X    # If nodename is unqualified, assume it's in namespace std.
X    if '::' not in nodename:
X        nodename = 'std::' + nodename
X    # Use either containertype's value_type or its first template argument.
X    try:
X        valtype = find_type(containertype, 'value_type')
X    except:
X        valtype = containertype.template_argument(0)
X    valtype = valtype.strip_typedefs()
X    try:
X        return lookup_templ_spec(nodename, valtype)
X    except gdb.error:
X        # For debug mode containers the node is in std::__cxx1998.
X        if is_member_of_namespace(nodename, 'std'):
X            if is_member_of_namespace(containertype, 'std::__cxx1998',
X                                      'std::__debug', '__gnu_debug'):
X                nodename = nodename.replace('::', '::__cxx1998::', 1)
X                try:
X                    return lookup_templ_spec(nodename, valtype)
X                except gdb.error:
X                    pass
X        return None
X
X
def is_member_of_namespace(typ, *namespaces):
X    """
X    Test whether a type is a member of one of the specified namespaces.
X    The type can be specified as a string or a gdb.Type object.
X    """
X    if isinstance(typ, gdb.Type):
X        typ = str(typ)
X    typ = strip_versioned_namespace(typ)
X    for namespace in namespaces:
X        if typ.startswith(namespace + '::'):
X            return True
X    return False
X
X
def is_specialization_of(x, template_name):
X    """
X    Test whether a type is a specialization of the named class template.
X    The type can be specified as a string or a gdb.Type object.
X    The template should be the name of a class template as a string,
X    without any 'std' qualification.
X    """
X    global _versioned_namespace
X    if isinstance(x, gdb.Type):
X        x = x.tag
X    template_name = '(%s)?%s' % (_versioned_namespace, template_name)
X    return re.match('^std::%s<.*>$' % template_name, x) is not None
X
X
def strip_versioned_namespace(typename):
X    global _versioned_namespace
X    return typename.replace(_versioned_namespace, '')
X
X
def strip_fundts_namespace(typ):
X    """Remove "fundamentals_vN" inline namespace from qualified type name."""
X    pattern = r'^std::experimental::fundamentals_v\d::'
X    repl = 'std::experimental::'
X    if sys.version_info[0] == 2:
X        return re.sub(pattern, repl, typ, 1)
X    else: # Technically this needs Python 3.1 but nobody should be using 3.0
X        return re.sub(pattern, repl, typ, count=1)
X
X
def strip_inline_namespaces(type_str):
X    """Remove known inline namespaces from the canonical name of a type."""
X    type_str = strip_versioned_namespace(type_str)
X    type_str = type_str.replace('std::__cxx11::', 'std::')
X    expt_ns = 'std::experimental::'
X    for lfts_ns in ('fundamentals_v1', 'fundamentals_v2'):
X        type_str = type_str.replace(expt_ns + lfts_ns + '::', expt_ns)
X    fs_ns = expt_ns + 'filesystem::'
X    type_str = type_str.replace(fs_ns + 'v1::', fs_ns)
X    return type_str
X
X
def get_template_arg_list(type_obj):
X    """Return a type's template arguments as a list."""
X    n = 0
X    template_args = []
X    while True:
X        try:
X            template_args.append(type_obj.template_argument(n))
X        except:
X            return template_args
X        n += 1
X
X
class SmartPtrIterator(Iterator):
X    """An iterator for smart pointer types with a single 'child' value."""
X
X    def __init__(self, val):
X        self._val = val
X
X    def __iter__(self):
X        return self
X
X    def __next__(self):
X        if self._val is None:
X            raise StopIteration
X        self._val, val = None, self._val
X        return ('get()', val)
X
X
class SharedPointerPrinter(printer_base):
X    """
X    Print a shared_ptr, weak_ptr, atomic<shared_ptr>, or atomic<weak_ptr>.
X    """
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X        self._pointer = val['_M_ptr']
X
X    def children(self):
X        return SmartPtrIterator(self._pointer)
X
X    # Return the _Sp_counted_base<>* that holds the refcounts.
X    def _get_refcounts(self):
X        if self._typename == 'std::atomic':
X            # A tagged pointer is stored as uintptr_t.
X            ptr_val = self._val['_M_refcount']['_M_val']['_M_i']
X            ptr_val = ptr_val - (ptr_val % 2)  # clear lock bit
X            ptr_type = find_type(self._val['_M_refcount'].type, 'pointer')
X            return ptr_val.cast(ptr_type)
X        return self._val['_M_refcount']['_M_pi']
X
X    def to_string(self):
X        state = 'empty'
X        refcounts = self._get_refcounts()
X        targ = self._val.type.template_argument(0)
X        targ = strip_versioned_namespace(str(targ))
X
X        if refcounts != 0:
X            usecount = refcounts['_M_use_count']
X            weakcount = refcounts['_M_weak_count']
X            if usecount == 0:
X                state = 'expired, weak count %d' % weakcount
X            else:
X                state = 'use count %d, weak count %d' % (
X                    usecount, weakcount - 1)
X        return '%s<%s> (%s)' % (self._typename, targ, state)
X
X
def _tuple_impl_get(val):
X    """Return the tuple element stored in a _Tuple_impl<N, T> base class."""
X    bases = val.type.fields()
X    if not bases[-1].is_base_class:
X        raise ValueError(
X            "Unsupported implementation for std::tuple: %s" % str(val.type))
X    # Get the _Head_base<N, T> base class:
X    head_base = val.cast(bases[-1].type)
X    fields = head_base.type.fields()
X    if len(fields) == 0:
X        raise ValueError(
X            "Unsupported implementation for std::tuple: %s" % str(val.type))
X    if fields[0].name == '_M_head_impl':
X        # The tuple element is the _Head_base::_M_head_impl data member.
X        return head_base['_M_head_impl']
X    elif fields[0].is_base_class:
X        # The tuple element is an empty base class of _Head_base.
X        # Cast to that empty base class.
X        return head_base.cast(fields[0].type)
X    else:
X        raise ValueError(
X            "Unsupported implementation for std::tuple: %s" % str(val.type))
X
X
def tuple_get(n, val):
X    """Return the result of std::get<n>(val) on a std::tuple."""
X    tuple_size = len(get_template_arg_list(val.type))
X    if n > tuple_size:
X        raise ValueError("Out of range index for std::get<N> on std::tuple")
X    # Get the first _Tuple_impl<0, T...> base class:
X    node = val.cast(val.type.fields()[0].type)
X    while n > 0:
X        # Descend through the base classes until the Nth one.
X        node = node.cast(node.type.fields()[0].type)
X        n -= 1
X    return _tuple_impl_get(node)
X
X
def unique_ptr_get(val):
X    """Return the result of val.get() on a std::unique_ptr."""
X    # std::unique_ptr<T, D> contains a std::tuple<D::pointer, D>,
X    # either as a direct data member _M_t (the old implementation)
X    # or within a data member of type __uniq_ptr_data.
X    impl_type = val.type.fields()[0].type.strip_typedefs()
X    # Check for new implementations first:
X    if is_specialization_of(impl_type, '__uniq_ptr_data') \
X            or is_specialization_of(impl_type, '__uniq_ptr_impl'):
X        tuple_member = val['_M_t']['_M_t']
X    elif is_specialization_of(impl_type, 'tuple'):
X        tuple_member = val['_M_t']
X    else:
X        raise ValueError(
X            "Unsupported implementation for unique_ptr: %s" % str(impl_type))
X    return tuple_get(0, tuple_member)
X
X
class UniquePointerPrinter(printer_base):
X    """Print a unique_ptr."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def children(self):
X        return SmartPtrIterator(unique_ptr_get(self._val))
X
X    def to_string(self):
X        t = self._val.type.template_argument(0)
X        return 'std::unique_ptr<{}>'.format(str(t))
X
X
def get_value_from_aligned_membuf(buf, valtype):
X    """Return the value held in a __gnu_cxx::__aligned_membuf."""
X    return buf['_M_storage'].address.cast(valtype.pointer()).dereference()
X
X
def get_value_from_list_node(node):
X    """Return the value held in an _List_node<_Val>."""
X    try:
X        member = node.type.fields()[1].name
X        if member == '_M_data':
X            # C++03 implementation, node contains the value as a member
X            return node['_M_data']
X        elif member == '_M_storage':
X            # C++11 implementation, node stores value in __aligned_membuf
X            valtype = node.type.template_argument(0)
X            return get_value_from_aligned_membuf(node['_M_storage'], valtype)
X    except:
X        pass
X    raise ValueError("Unsupported implementation for %s" % str(node.type))
X
X
class StdListPrinter(printer_base):
X    """Print a std::list."""
X
X    class _iterator(Iterator):
X        def __init__(self, nodetype, head):
X            self._nodetype = nodetype
X            self._base = head['_M_next']
X            self._head = head.address
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._base == self._head:
X                raise StopIteration
X            elt = self._base.cast(self._nodetype).dereference()
X            self._base = elt['_M_next']
X            count = self._count
X            self._count = self._count + 1
X            val = get_value_from_list_node(elt)
X            return ('[%d]' % count, val)
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def children(self):
X        nodetype = lookup_node_type('_List_node', self._val.type).pointer()
X        return self._iterator(nodetype, self._val['_M_impl']['_M_node'])
X
X    def to_string(self):
X        headnode = self._val['_M_impl']['_M_node']
X        if headnode['_M_next'] == headnode.address:
X            return 'empty %s' % (self._typename)
X        return '%s' % (self._typename)
X
X
class NodeIteratorPrinter(printer_base):
X    def __init__(self, typename, val, contname, nodename):
X        self._val = val
X        self._typename = typename
X        self._contname = contname
X        self._nodetype = lookup_node_type(nodename, val.type)
X
X    def to_string(self):
X        if not self._val['_M_node']:
X            return 'non-dereferenceable iterator for std::%s' % (self._contname)
X        node = self._val['_M_node'].cast(
X            self._nodetype.pointer()).dereference()
X        return str(get_value_from_list_node(node))
X
X
class StdListIteratorPrinter(NodeIteratorPrinter):
X    """Print std::list::iterator."""
X
X    def __init__(self, typename, val):
X        NodeIteratorPrinter.__init__(self, typename, val, 'list', '_List_node')
X
X
class StdFwdListIteratorPrinter(NodeIteratorPrinter):
X    """Print std::forward_list::iterator."""
X
X    def __init__(self, typename, val):
X        NodeIteratorPrinter.__init__(self, typename, val, 'forward_list',
X                                     '_Fwd_list_node')
X
X
class StdSlistPrinter(printer_base):
X    """Print a __gnu_cxx::slist."""
X
X    class _iterator(Iterator):
X        def __init__(self, nodetype, head):
X            self._nodetype = nodetype
X            self._base = head['_M_head']['_M_next']
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._base == 0:
X                raise StopIteration
X            elt = self._base.cast(self._nodetype).dereference()
X            self._base = elt['_M_next']
X            count = self._count
X            self._count = self._count + 1
X            return ('[%d]' % count, elt['_M_data'])
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def children(self):
X        nodetype = lookup_node_type('__gnu_cxx::_Slist_node', self._val.type)
X        return self._iterator(nodetype.pointer(), self._val)
X
X    def to_string(self):
X        if self._val['_M_head']['_M_next'] == 0:
X            return 'empty __gnu_cxx::slist'
X        return '__gnu_cxx::slist'
X
X
class StdSlistIteratorPrinter(printer_base):
X    """Print __gnu_cxx::slist::iterator."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def to_string(self):
X        if not self._val['_M_node']:
X            return 'non-dereferenceable iterator for __gnu_cxx::slist'
X        nodetype = lookup_node_type(
X            '__gnu_cxx::_Slist_node', self._val.type).pointer()
X        return str(self._val['_M_node'].cast(nodetype).dereference()['_M_data'])
X
X
class StdVectorPrinter(printer_base):
X    """Print a std::vector."""
X
X    class _iterator(Iterator):
X        def __init__(self, start, finish, bitvec):
X            self._bitvec = bitvec
X            if bitvec:
X                self._item = start['_M_p']
X                self._so = 0
X                self._finish = finish['_M_p']
X                self._fo = finish['_M_offset']
X                itype = self._item.dereference().type
X                self._isize = 8 * itype.sizeof
X            else:
X                self._item = start
X                self._finish = finish
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            count = self._count
X            self._count = self._count + 1
X            if self._bitvec:
X                if self._item == self._finish and self._so >= self._fo:
X                    raise StopIteration
X                elt = bool(self._item.dereference() & (1 << self._so))
X                self._so = self._so + 1
X                if self._so >= self._isize:
X                    self._item = self._item + 1
X                    self._so = 0
X                return ('[%d]' % count, elt)
X            else:
X                if self._item == self._finish:
X                    raise StopIteration
X                elt = self._item.dereference()
X                self._item = self._item + 1
X                return ('[%d]' % count, elt)
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X        self._is_bool = val.type.template_argument(
X            0).code == gdb.TYPE_CODE_BOOL
X
X    def children(self):
X        return self._iterator(self._val['_M_impl']['_M_start'],
X                              self._val['_M_impl']['_M_finish'],
X                              self._is_bool)
X
X    def to_string(self):
X        start = self._val['_M_impl']['_M_start']
X        finish = self._val['_M_impl']['_M_finish']
X        end = self._val['_M_impl']['_M_end_of_storage']
X        if self._is_bool:
X            start = self._val['_M_impl']['_M_start']['_M_p']
X            finish = self._val['_M_impl']['_M_finish']['_M_p']
X            fo = self._val['_M_impl']['_M_finish']['_M_offset']
X            itype = start.dereference().type
X            bl = 8 * itype.sizeof
X            length = bl * (finish - start) + fo
X            capacity = bl * (end - start)
X            return ('%s<bool> of length %d, capacity %d'
X                    % (self._typename, int(length), int(capacity)))
X        else:
X            return ('%s of length %d, capacity %d'
X                    % (self._typename, int(finish - start), int(end - start)))
X
X    def display_hint(self):
X        return 'array'
X
X
class StdVectorIteratorPrinter(printer_base):
X    """Print std::vector::iterator."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def to_string(self):
X        if not self._val['_M_current']:
X            return 'non-dereferenceable iterator for std::vector'
X        return str(self._val['_M_current'].dereference())
X
X
class StdBitIteratorPrinter(printer_base):
X    """Print std::vector<bool>'s _Bit_iterator and _Bit_const_iterator."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def to_string(self):
X        if not self._val['_M_p']:
X            return 'non-dereferenceable iterator for std::vector<bool>'
X        return bool(self._val['_M_p'].dereference()
X                    & (1 << self._val['_M_offset']))
X
X
class StdBitReferencePrinter(printer_base):
X    """Print std::vector<bool>::reference."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def to_string(self):
X        if not self._val['_M_p']:
X            return 'invalid std::vector<bool>::reference'
X        return bool(self._val['_M_p'].dereference() & (self._val['_M_mask']))
X
X
class StdTuplePrinter(printer_base):
X    """Print a std::tuple."""
X
X    class _iterator(Iterator):
X        @staticmethod
X        def _is_nonempty_tuple(nodes):
X            if len(nodes) == 2:
X                if is_specialization_of(nodes[1].type, '__tuple_base'):
X                    return True
X            elif len(nodes) == 1:
X                return True
X            elif len(nodes) == 0:
X                return False
X            raise ValueError(
X                "Top of tuple tree does not consist of a single node.")
X
X        def __init__(self, head):
X            self._head = head
X
X            # Set the base class as the initial head of the
X            # tuple.
X            nodes = self._head.type.fields()
X            if self._is_nonempty_tuple(nodes):
X                # Set the actual head to the first pair.
X                self._head = self._head.cast(nodes[0].type)
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            # Check for further recursions in the inheritance tree.
X            # For a GCC 5+ tuple self._head is None after visiting all nodes:
X            if not self._head:
X                raise StopIteration
X            nodes = self._head.type.fields()
X            # For a GCC 4.x tuple there is a final node with no fields:
X            if len(nodes) == 0:
X                raise StopIteration
X            # Check that this iteration has an expected structure.
X            if len(nodes) > 2:
X                raise ValueError(
X                    "Cannot parse more than 2 nodes in a tuple tree.")
X
X            if len(nodes) == 1:
X                # This is the last node of a GCC 5+ std::tuple.
X                impl = self._head.cast(nodes[0].type)
X                self._head = None
X            else:
X                # Either a node before the last node, or the last node of
X                # a GCC 4.x tuple (which has an empty parent).
X
X                # - Left node is the next recursion parent.
X                # - Right node is the actual class contained in the tuple.
X
X                # Process right node.
X                impl = self._head.cast(nodes[1].type)
X
X                # Process left node and set it as head.
X                self._head = self._head.cast(nodes[0].type)
X
X            self._count = self._count + 1
X
X            # Finally, check the implementation.  If it is
X            # wrapped in _M_head_impl return that, otherwise return
X            # the value "as is".
X            fields = impl.type.fields()
X            if len(fields) < 1 or fields[0].name != "_M_head_impl":
X                return ('[%d]' % (self._count - 1), impl)
X            else:
X                return ('[%d]' % (self._count - 1), impl['_M_head_impl'])
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def children(self):
X        return self._iterator(self._val)
X
X    def to_string(self):
X        if len(self._val.type.fields()) == 0:
X            return 'empty %s' % (self._typename)
X        return '%s containing' % (self._typename)
X
X
class StdStackOrQueuePrinter(printer_base):
X    """Print a std::stack or std::queue."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._visualizer = gdb.default_visualizer(val['c'])
X
X    def children(self):
X        return self._visualizer.children()
X
X    def to_string(self):
X        return '%s wrapping: %s' % (self._typename,
X                                    self._visualizer.to_string())
X
X    def display_hint(self):
X        if hasattr(self._visualizer, 'display_hint'):
X            return self._visualizer.display_hint()
X        return None
X
X
class RbtreeIterator(Iterator):
X    """
X    Turn an RB-tree-based container (std::map, std::set etc.) into
X    a Python iterable object.
X    """
X
X    def __init__(self, rbtree):
X        self._size = rbtree['_M_t']['_M_impl']['_M_node_count']
X        self._node = rbtree['_M_t']['_M_impl']['_M_header']['_M_left']
X        self._count = 0
X
X    def __iter__(self):
X        return self
X
X    def __len__(self):
X        return int(self._size)
X
X    def __next__(self):
X        if self._count == self._size:
X            raise StopIteration
X        result = self._node
X        self._count = self._count + 1
X        if self._count < self._size:
X            # Compute the next node.
X            node = self._node
X            if node.dereference()['_M_right']:
X                node = node.dereference()['_M_right']
X                while node.dereference()['_M_left']:
X                    node = node.dereference()['_M_left']
X            else:
X                parent = node.dereference()['_M_parent']
X                while node == parent.dereference()['_M_right']:
X                    node = parent
X                    parent = parent.dereference()['_M_parent']
X                if node.dereference()['_M_right'] != parent:
X                    node = parent
X            self._node = node
X        return result
X
X
def get_value_from_Rb_tree_node(node):
X    """Return the value held in an _Rb_tree_node<_Val>."""
X    try:
X        member = node.type.fields()[1].name
X        if member == '_M_value_field':
X            # C++03 implementation, node contains the value as a member
X            return node['_M_value_field']
X        elif member == '_M_storage':
X            # C++11 implementation, node stores value in __aligned_membuf
X            valtype = node.type.template_argument(0)
X            return get_value_from_aligned_membuf(node['_M_storage'], valtype)
X    except:
X        pass
X    raise ValueError("Unsupported implementation for %s" % str(node.type))
X
# This is a pretty printer for std::_Rb_tree_iterator (which is
# std::map::iterator), and has nothing to do with the RbtreeIterator
# class above.
X
X
class StdRbtreeIteratorPrinter(printer_base):
X    """Print std::map::iterator, std::set::iterator, etc."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        nodetype = lookup_node_type('_Rb_tree_node', self._val.type)
X        self._link_type = nodetype.pointer()
X
X    def to_string(self):
X        if not self._val['_M_node']:
X            return 'non-dereferenceable iterator for associative container'
X        node = self._val['_M_node'].cast(self._link_type).dereference()
X        return str(get_value_from_Rb_tree_node(node))
X
X
class StdDebugIteratorPrinter(printer_base):
X    """Print a debug enabled version of an iterator."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    # Just strip away the encapsulating __gnu_debug::_Safe_iterator
X    # and return the wrapped iterator value.
X    def to_string(self):
X        base_type = gdb.lookup_type('__gnu_debug::_Safe_iterator_base')
X        itype = self._val.type.template_argument(0)
X        safe_seq = self._val.cast(base_type)['_M_sequence']
X        if not safe_seq:
X            return str(self._val.cast(itype))
X        if self._val['_M_version'] != safe_seq['_M_version']:
X            return "invalid iterator"
X        return str(self._val.cast(itype))
X
X
def num_elements(num):
X    """Return either "1 element" or "N elements" depending on the argument."""
X    return '1 element' if num == 1 else '%d elements' % num
X
X
class StdMapPrinter(printer_base):
X    """Print a std::map or std::multimap."""
X
X    # Turn an RbtreeIterator into a pretty-print iterator.
X    class _iter(Iterator):
X        def __init__(self, rbiter, type):
X            self._rbiter = rbiter
X            self._count = 0
X            self._type = type
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._count % 2 == 0:
X                n = next(self._rbiter)
X                n = n.cast(self._type).dereference()
X                n = get_value_from_Rb_tree_node(n)
X                self._pair = n
X                item = n['first']
X            else:
X                item = self._pair['second']
X            result = ('[%d]' % self._count, item)
X            self._count = self._count + 1
X            return result
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        return '%s with %s' % (self._typename,
X                               num_elements(len(RbtreeIterator(self._val))))
X
X    def children(self):
X        node = lookup_node_type('_Rb_tree_node', self._val.type).pointer()
X        return self._iter(RbtreeIterator(self._val), node)
X
X    def display_hint(self):
X        return 'map'
X
X
class StdSetPrinter(printer_base):
X    """Print a std::set or std::multiset."""
X
X    # Turn an RbtreeIterator into a pretty-print iterator.
X    class _iter(Iterator):
X        def __init__(self, rbiter, type):
X            self._rbiter = rbiter
X            self._count = 0
X            self._type = type
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            item = next(self._rbiter)
X            item = item.cast(self._type).dereference()
X            item = get_value_from_Rb_tree_node(item)
X            # FIXME: this is weird ... what to do?
X            # Maybe a 'set' display hint?
X            result = ('[%d]' % self._count, item)
X            self._count = self._count + 1
X            return result
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        return '%s with %s' % (self._typename,
X                               num_elements(len(RbtreeIterator(self._val))))
X
X    def children(self):
X        node = lookup_node_type('_Rb_tree_node', self._val.type).pointer()
X        return self._iter(RbtreeIterator(self._val), node)
X
X
class StdBitsetPrinter(printer_base):
X    """Print a std::bitset."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        # If template_argument handled values, we could print the
X        # size.  Or we could use a regexp on the type.
X        return '%s' % (self._typename)
X
X    def children(self):
X        try:
X            # An empty bitset may not have any members which will
X            # result in an exception being thrown.
X            words = self._val['_M_w']
X        except:
X            return []
X
X        wtype = words.type
X
X        # The _M_w member can be either an unsigned long, or an
X        # array.  This depends on the template specialization used.
X        # If it is a single long, convert to a single element list.
X        if wtype.code == gdb.TYPE_CODE_ARRAY:
X            tsize = wtype.target().sizeof
X        else:
X            words = [words]
X            tsize = wtype.sizeof
X
X        nwords = wtype.sizeof / tsize
X        result = []
X        byte = 0
X        while byte < nwords:
X            w = words[byte]
X            bit = 0
X            while w != 0:
X                if (w & 1) != 0:
X                    # Another spot where we could use 'set'?
X                    result.append(('[%d]' % (byte * tsize * 8 + bit), 1))
X                bit = bit + 1
X                w = w >> 1
X            byte = byte + 1
X        return result
X
X
class StdDequePrinter(printer_base):
X    """Print a std::deque."""
X
X    class _iter(Iterator):
X        def __init__(self, node, start, end, last, buffer_size):
X            self._node = node
X            self._p = start
X            self._end = end
X            self._last = last
X            self._buffer_size = buffer_size
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._p == self._last:
X                raise StopIteration
X
X            result = ('[%d]' % self._count, self._p.dereference())
X            self._count = self._count + 1
X
X            # Advance the 'cur' pointer.
X            self._p = self._p + 1
X            if self._p == self._end:
X                # If we got to the end of this bucket, move to the
X                # next bucket.
X                self._node = self._node + 1
X                self._p = self._node[0]
X                self._end = self._p + self._buffer_size
X
X            return result
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X        self._elttype = val.type.template_argument(0)
X        size = self._elttype.sizeof
X        if size < 512:
X            self._buffer_size = int(512 / size)
X        else:
X            self._buffer_size = 1
X
X    def to_string(self):
X        start = self._val['_M_impl']['_M_start']
X        end = self._val['_M_impl']['_M_finish']
X
X        delta_n = end['_M_node'] - start['_M_node'] - 1
X        delta_s = start['_M_last'] - start['_M_cur']
X        delta_e = end['_M_cur'] - end['_M_first']
X
X        size = self._buffer_size * delta_n + delta_s + delta_e
X
X        return '%s with %s' % (self._typename, num_elements(long(size)))
X
X    def children(self):
X        start = self._val['_M_impl']['_M_start']
X        end = self._val['_M_impl']['_M_finish']
X        return self._iter(start['_M_node'], start['_M_cur'], start['_M_last'],
X                          end['_M_cur'], self._buffer_size)
X
X    def display_hint(self):
X        return 'array'
X
X
class StdDequeIteratorPrinter(printer_base):
X    """Print std::deque::iterator."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def to_string(self):
X        if not self._val['_M_cur']:
X            return 'non-dereferenceable iterator for std::deque'
X        return str(self._val['_M_cur'].dereference())
X
X
class StdStringPrinter(printer_base):
X    """Print a std::basic_string of some kind."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._new_string = typename.find("::__cxx11::basic_string") != -1
X
X    def to_string(self):
X        # Make sure &string works, too.
X        type = self._val.type
X        if type.code == gdb.TYPE_CODE_REF:
X            type = type.target()
X
X        # Calculate the length of the string so that to_string returns
X        # the string according to length, not according to first null
X        # encountered.
X        ptr = self._val['_M_dataplus']['_M_p']
X        if self._new_string:
X            length = self._val['_M_string_length']
X            # https://sourceware.org/bugzilla/show_bug.cgi?id=17728
X            ptr = ptr.cast(ptr.type.strip_typedefs())
X        else:
X            realtype = type.unqualified().strip_typedefs()
X            reptype = gdb.lookup_type(str(realtype) + '::_Rep').pointer()
X            header = ptr.cast(reptype) - 1
X            length = header.dereference()['_M_length']
X        if hasattr(ptr, "lazy_string"):
X            return ptr.lazy_string(length=length)
X        return ptr.string(length=length)
X
X    def display_hint(self):
X        return 'string'
X
X
def access_streambuf_ptrs(streambuf):
X    """Access the streambuf put area pointers."""
X    pbase = streambuf['_M_out_beg']
X    pptr = streambuf['_M_out_cur']
X    egptr = streambuf['_M_in_end']
X    return pbase, pptr, egptr
X
X
class StdStringBufPrinter(printer_base):
X    """Print a std::basic_stringbuf."""
X
X    def __init__(self, _, val):
X        self._val = val
X
X    def to_string(self):
X        (pbase, pptr, egptr) = access_streambuf_ptrs(self._val)
X        # Logic from basic_stringbuf::_M_high_mark()
X        if pptr:
X            if not egptr or pptr > egptr:
X                return pbase.string(length=pptr - pbase)
X            else:
X                return pbase.string(length=egptr - pbase)
X        return self._val['_M_string']
X
X    def display_hint(self):
X        return 'string'
X
X
class StdStringStreamPrinter(printer_base):
X    """Print a std::basic_stringstream."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = typename
X
X        # Check if the stream was redirected. This is essentially:
X        # val['_M_streambuf'] != val['_M_stringbuf'].address
X        # However, GDB can't resolve the virtual inheritance, so we do that
X        # manually.
X        basetype = [f.type for f in val.type.fields() if f.is_base_class][0]
X        gdb.set_convenience_variable('__stream', val.cast(basetype).address)
X        self._streambuf = gdb.parse_and_eval('$__stream->rdbuf()')
X        self._was_redirected = self._streambuf != val['_M_stringbuf'].address
X
X    def to_string(self):
X        if self._was_redirected:
X            return "%s redirected to %s" % (
X                self._typename, self._streambuf.dereference())
X        return self._val['_M_stringbuf']
X
X    def display_hint(self):
X        if self._was_redirected:
X            return None
X        return 'string'
X
X
class Tr1HashtableIterator(Iterator):
X    def __init__(self, hashtable):
X        self._buckets = hashtable['_M_buckets']
X        self._bucket = 0
X        self._bucket_count = hashtable['_M_bucket_count']
X        self._node_type = find_type(hashtable.type, '_Node').pointer()
X        self._node = 0
X        while self._bucket != self._bucket_count:
X            self._node = self._buckets[self._bucket]
X            if self._node:
X                break
X            self._bucket = self._bucket + 1
X
X    def __iter__(self):
X        return self
X
X    def __next__(self):
X        if self._node == 0:
X            raise StopIteration
X        node = self._node.cast(self._node_type)
X        result = node.dereference()['_M_v']
X        self._node = node.dereference()['_M_next']
X        if self._node == 0:
X            self._bucket = self._bucket + 1
X            while self._bucket != self._bucket_count:
X                self._node = self._buckets[self._bucket]
X                if self._node:
X                    break
X                self._bucket = self._bucket + 1
X        return result
X
X
class StdHashtableIterator(Iterator):
X    def __init__(self, hashtable):
X        self._node = hashtable['_M_before_begin']['_M_nxt']
X        valtype = hashtable.type.template_argument(1)
X        cached = hashtable.type.template_argument(9).template_argument(0)
X        node_type = lookup_templ_spec('std::__detail::_Hash_node', str(valtype),
X                                      'true' if cached else 'false')
X        self._node_type = node_type.pointer()
X
X    def __iter__(self):
X        return self
X
X    def __next__(self):
X        if self._node == 0:
X            raise StopIteration
X        elt = self._node.cast(self._node_type).dereference()
X        self._node = elt['_M_nxt']
X        valptr = elt['_M_storage'].address
X        valptr = valptr.cast(elt.type.template_argument(0).pointer())
X        return valptr.dereference()
X
X
class Tr1UnorderedSetPrinter(printer_base):
X    """Print a std::unordered_set or tr1::unordered_set."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def _hashtable(self):
X        if self._typename.startswith('std::tr1'):
X            return self._val
X        return self._val['_M_h']
X
X    def to_string(self):
X        count = self._hashtable()['_M_element_count']
X        return '%s with %s' % (self._typename, num_elements(count))
X
X    @staticmethod
X    def _format_count(i):
X        return '[%d]' % i
X
X    def children(self):
X        counter = imap(self._format_count, itertools.count())
X        if self._typename.startswith('std::tr1'):
X            return izip(counter, Tr1HashtableIterator(self._hashtable()))
X        return izip(counter, StdHashtableIterator(self._hashtable()))
X
X
class Tr1UnorderedMapPrinter(printer_base):
X    """Print a std::unordered_map or tr1::unordered_map."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def _hashtable(self):
X        if self._typename.startswith('std::tr1'):
X            return self._val
X        return self._val['_M_h']
X
X    def to_string(self):
X        count = self._hashtable()['_M_element_count']
X        return '%s with %s' % (self._typename, num_elements(count))
X
X    @staticmethod
X    def _flatten(list):
X        for elt in list:
X            for i in elt:
X                yield i
X
X    @staticmethod
X    def _format_one(elt):
X        return (elt['first'], elt['second'])
X
X    @staticmethod
X    def _format_count(i):
X        return '[%d]' % i
X
X    def children(self):
X        counter = imap(self._format_count, itertools.count())
X        # Map over the hash table and flatten the result.
X        if self._typename.startswith('std::tr1'):
X            data = self._flatten(
X                imap(self._format_one, Tr1HashtableIterator(self._hashtable())))
X            # Zip the two iterators together.
X            return izip(counter, data)
X        data = self._flatten(
X            imap(self._format_one, StdHashtableIterator(self._hashtable())))
X        # Zip the two iterators together.
X        return izip(counter, data)
X
X    def display_hint(self):
X        return 'map'
X
X
class StdForwardListPrinter(printer_base):
X    """Print a std::forward_list."""
X
X    class _iterator(Iterator):
X        def __init__(self, nodetype, head):
X            self._nodetype = nodetype
X            self._base = head['_M_next']
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._base == 0:
X                raise StopIteration
X            elt = self._base.cast(self._nodetype).dereference()
X            self._base = elt['_M_next']
X            count = self._count
X            self._count = self._count + 1
X            valptr = elt['_M_storage'].address
X            valptr = valptr.cast(elt.type.template_argument(0).pointer())
X            return ('[%d]' % count, valptr.dereference())
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = strip_versioned_namespace(typename)
X
X    def children(self):
X        nodetype = lookup_node_type('_Fwd_list_node', self._val.type).pointer()
X        return self._iterator(nodetype, self._val['_M_impl']['_M_head'])
X
X    def to_string(self):
X        if self._val['_M_impl']['_M_head']['_M_next'] == 0:
X            return 'empty %s' % self._typename
X        return '%s' % self._typename
X
X
class SingleObjContainerPrinter(printer_base):
X    """Base class for printers of containers of single objects."""
X
X    def __init__(self, val, viz, hint=None):
X        self._contained_value = val
X        self._visualizer = viz
X        self._hint = hint
X
X    def _recognize(self, type):
X        """Return type as a string after applying type printers."""
X        global _use_type_printing
X        if not _use_type_printing:
X            return str(type)
X        return gdb.types.apply_type_recognizers(gdb.types.get_type_recognizers(),
X                                                type) or str(type)
X
X    class _contained(Iterator):
X        def __init__(self, val):
X            self._val = val
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._val is None:
X                raise StopIteration
X            retval = self._val
X            self._val = None
X            return ('[contained value]', retval)
X
X    def children(self):
X        if self._contained_value is None:
X            return self._contained(None)
X        if hasattr(self._visualizer, 'children'):
X            return self._visualizer.children()
X        return self._contained(self._contained_value)
X
X    def display_hint(self):
X        if (hasattr(self._visualizer, 'children')
X                and hasattr(self._visualizer, 'display_hint')):
X            # If contained value is a map we want to display in the same way.
X            return self._visualizer.display_hint()
X        return self._hint
X
X
def function_pointer_to_name(f):
X    """Find the name of the function referred to by the gdb.Value f,
X    which should contain a function pointer from the program."""
X
X    # Turn the function pointer into an actual address.
X    # This is needed to unpack ppc64 function descriptors.
X    f = f.dereference().address
X
X    if sys.version_info[0] == 2:
X        # Older versions of GDB need to use long for Python 2,
X        # because int(f) on 64-bit big-endian values raises a
X        # gdb.error saying "Cannot convert value to int."
X        f = long(f)
X    else:
X        f = int(f)
X
X    try:
X        # If the function can't be found older versions of GDB raise a
X        # RuntimeError saying "Cannot locate object file for block."
X        return gdb.block_for_pc(f).function.name
X    except:
X        return None
X
X
class StdExpAnyPrinter(SingleObjContainerPrinter):
X    """Print a std::any or std::experimental::any."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._typename = strip_fundts_namespace(self._typename)
X        self._val = val
X        self._contained_type = None
X        contained_value = None
X        visualizer = None
X        mgr = self._val['_M_manager']
X        if mgr != 0:
X            func = function_pointer_to_name(mgr)
X            if not func:
X                raise ValueError(
X                    "Invalid function pointer in %s" % (self._typename))
X            # We want to use this regular expression:
X            # T::_Manager_xxx<.*>::_S_manage\(T::_Op, const T\*, T::_Arg\*\)
X            # where T is std::any or std::experimental::any.
X            # But we need to account for variances in demangled names
X            # between GDB versions, e.g. 'enum T::_Op' instead of 'T::_Op'.
X            rx = (
X                r"({0}::_Manager_\w+<.*>)::_S_manage\("
X                r"(enum )?{0}::_Op, (const {0}|{0} const) ?\*, "
X                r"(union )?{0}::_Arg ?\*\)"
X            ).format(typename)
X            m = re.match(rx, func)
X            if not m:
X                raise ValueError(
X                    "Unknown manager function in %s" % self._typename)
X
X            mgrname = m.group(1)
X            # FIXME need to expand 'std::string' so that gdb.lookup_type works
X            if 'std::string' in mgrname:
X                mgrtypes = []
X                for s in StdExpAnyPrinter._string_types():
X                    try:
X                        x = re.sub(r"std::string(?!\w)", s, m.group(1))
X                        # The following lookup might raise gdb.error if the
X                        # manager function was never instantiated for 's' in
X                        # the program, because there will be no such type.
X                        mgrtypes.append(gdb.lookup_type(x))
X                    except gdb.error:
X                        pass
X                if len(mgrtypes) != 1:
X                    # FIXME: this is unlikely in practice, but possible for
X                    # programs that use both old and new string types with
X                    # std::any in a single program. Can we do better?
X                    # Maybe find the address of each type's _S_manage and
X                    # compare to the address stored in _M_manager?
X                    raise ValueError(
X                        'Cannot uniquely determine std::string type '
X                        'used in std::any'
X                    )
X                mgrtype = mgrtypes[0]
X            else:
X                mgrtype = gdb.lookup_type(mgrname)
X            self._contained_type = mgrtype.template_argument(0)
X            valptr = None
X            if '::_Manager_internal' in mgrname:
X                valptr = self._val['_M_storage']['_M_buffer'].address
X            elif '::_Manager_external' in mgrname:
X                valptr = self._val['_M_storage']['_M_ptr']
X            else:
X                raise ValueError(
X                    "Unknown manager function in %s" % self._typename)
X            contained_value = valptr.cast(
X                self._contained_type.pointer()).dereference()
X            visualizer = gdb.default_visualizer(contained_value)
X        super(StdExpAnyPrinter, self).__init__(contained_value, visualizer)
X
X    def to_string(self):
X        if self._contained_type is None:
X            return '%s [no contained value]' % self._typename
X        desc = "%s containing " % self._typename
X        if hasattr(self._visualizer, 'children'):
X            return desc + self._visualizer.to_string()
X        valtype = self._recognize(self._contained_type)
X        return desc + strip_versioned_namespace(str(valtype))
X
X    @staticmethod
X    def _string_types():
X        # This lookup for std::string might return the __cxx11 version,
X        # but that's not necessarily the one used by the std::any
X        # manager function we're trying to find.
X        strings = {str(gdb.lookup_type('std::string').strip_typedefs())}
X        # So also consider all the other possible std::string types!
X        s = 'basic_string<char, std::char_traits<char>, std::allocator<char> >'
X        quals = ['std::', 'std::__cxx11::',
X                 'std::' + _versioned_namespace]
X        strings |= {q + s for q in quals}  # set of unique strings
X        return strings
X
X
class StdExpOptionalPrinter(SingleObjContainerPrinter):
X    """Print a std::optional or std::experimental::optional."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._typename = strip_fundts_namespace(self._typename)
X        payload = val['_M_payload']
X        if self._typename.startswith('std::experimental'):
X            engaged = val['_M_engaged']
X            contained_value = payload
X        else:
X            engaged = payload['_M_engaged']
X            contained_value = payload['_M_payload']
X            try:
X                # Since GCC 9
X                contained_value = contained_value['_M_value']
X            except:
X                pass
X        visualizer = gdb.default_visualizer(contained_value)
X        if not engaged:
X            contained_value = None
X        super(StdExpOptionalPrinter, self).__init__(
X            contained_value, visualizer)
X
X    def to_string(self):
X        if self._contained_value is None:
X            return "%s [no contained value]" % self._typename
X        if hasattr(self._visualizer, 'children'):
X            return "%s containing %s" % (self._typename,
X                                         self._visualizer.to_string())
X        return self._typename
X
X
class StdVariantPrinter(SingleObjContainerPrinter):
X    """Print a std::variant."""
X
X    def __init__(self, typename, val):
X        alternatives = get_template_arg_list(val.type)
X        self._typename = strip_versioned_namespace(typename)
X        self._index = val['_M_index']
X        if self._index >= len(alternatives):
X            self._contained_type = None
X            contained_value = None
X            visualizer = None
X        else:
X            self._contained_type = alternatives[int(self._index)]
X            addr = val['_M_u']['_M_first']['_M_storage'].address
X            contained_value = addr.cast(
X                self._contained_type.pointer()).dereference()
X            visualizer = gdb.default_visualizer(contained_value)
X        super(StdVariantPrinter, self).__init__(
X            contained_value, visualizer, 'array')
X
X    def to_string(self):
X        if self._contained_value is None:
X            return "%s [no contained value]" % self._typename
X        if hasattr(self._visualizer, 'children'):
X            return "%s [index %d] containing %s" % (self._typename, self._index,
X                                                    self._visualizer.to_string())
X        return "%s [index %d]" % (self._typename, self._index)
X
X
class StdNodeHandlePrinter(SingleObjContainerPrinter):
X    """Print a container node handle."""
X
X    def __init__(self, typename, val):
X        self._value_type = val.type.template_argument(1)
X        nodetype = val.type.template_argument(2).template_argument(0)
X        self._is_rb_tree_node = is_specialization_of(
X            nodetype.name, '_Rb_tree_node')
X        self._is_map_node = val.type.template_argument(0) != self._value_type
X        nodeptr = val['_M_ptr']
X        if nodeptr:
X            if self._is_rb_tree_node:
X                contained_value = get_value_from_Rb_tree_node(
X                    nodeptr.dereference())
X            else:
X                contained_value = get_value_from_aligned_membuf(nodeptr['_M_storage'],
X                                                                self._value_type)
X            visualizer = gdb.default_visualizer(contained_value)
X        else:
X            contained_value = None
X            visualizer = None
X        optalloc = val['_M_alloc']
X        self._alloc = optalloc['_M_payload'] if optalloc['_M_engaged'] else None
X        super(StdNodeHandlePrinter, self).__init__(contained_value, visualizer,
X                                                   'array')
X
X    def to_string(self):
X        desc = 'node handle for '
X        if not self._is_rb_tree_node:
X            desc += 'unordered '
X        if self._is_map_node:
X            desc += 'map'
X        else:
X            desc += 'set'
X
X        if self._contained_value:
X            desc += ' with element'
X            if hasattr(self._visualizer, 'children'):
X                return "%s = %s" % (desc, self._visualizer.to_string())
X            return desc
X        else:
X            return 'empty %s' % desc
X
X
class StdExpStringViewPrinter(printer_base):
X    """
X    Print a std::basic_string_view or std::experimental::basic_string_view
X    """
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    def to_string(self):
X        ptr = self._val['_M_str']
X        len = self._val['_M_len']
X        if hasattr(ptr, "lazy_string"):
X            return ptr.lazy_string(length=len)
X        return ptr.string(length=len)
X
X    def display_hint(self):
X        return 'string'
X
X
class StdExpPathPrinter(printer_base):
X    """Print a std::experimental::filesystem::path."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = typename
X        start = self._val['_M_cmpts']['_M_impl']['_M_start']
X        finish = self._val['_M_cmpts']['_M_impl']['_M_finish']
X        self._num_cmpts = int(finish - start)
X
X    def _path_type(self):
X        t = str(self._val['_M_type'])
X        if t[-9:] == '_Root_dir':
X            return "root-directory"
X        if t[-10:] == '_Root_name':
X            return "root-name"
X        return None
X
X    def to_string(self):
X        path = "%s" % self._val['_M_pathname']
X        if self._num_cmpts == 0:
X            t = self._path_type()
X            if t:
X                path = '%s [%s]' % (path, t)
X        return "experimental::filesystem::path %s" % path
X
X    class _iterator(Iterator):
X        def __init__(self, cmpts, pathtype):
X            self._pathtype = pathtype
X            self._item = cmpts['_M_impl']['_M_start']
X            self._finish = cmpts['_M_impl']['_M_finish']
X            self._count = 0
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._item == self._finish:
X                raise StopIteration
X            item = self._item.dereference()
X            count = self._count
X            self._count = self._count + 1
X            self._item = self._item + 1
X            path = item['_M_pathname']
X            t = StdExpPathPrinter(self._pathtype, item)._path_type()
X            if not t:
X                t = count
X            return ('[%s]' % t, path)
X
X    def children(self):
X        return self._iterator(self._val['_M_cmpts'], self._typename)
X
X
class StdPathPrinter(printer_base):
X    """Print a std::filesystem::path."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = typename
X        impl = unique_ptr_get(self._val['_M_cmpts']['_M_impl'])
X        self._type = impl.cast(gdb.lookup_type('uintptr_t')) & 3
X        if self._type == 0:
X            self._impl = impl
X        else:
X            self._impl = None
X
X    def _path_type(self):
X        t = str(self._type.cast(gdb.lookup_type(self._typename + '::_Type')))
X        if t[-9:] == '_Root_dir':
X            return "root-directory"
X        if t[-10:] == '_Root_name':
X            return "root-name"
X        return None
X
X    def to_string(self):
X        path = "%s" % self._val['_M_pathname']
X        if self._type != 0:
X            t = self._path_type()
X            if t:
X                path = '%s [%s]' % (path, t)
X        return "filesystem::path %s" % path
X
X    class _iterator(Iterator):
X        def __init__(self, impl, pathtype):
X            self._pathtype = pathtype
X            if impl:
X                # We can't access _Impl::_M_size because _Impl is incomplete
X                # so cast to int* to access the _M_size member at offset zero,
X                int_type = gdb.lookup_type('int')
X                cmpt_type = gdb.lookup_type(pathtype + '::_Cmpt')
X                char_type = gdb.lookup_type('char')
X                impl = impl.cast(int_type.pointer())
X                size = impl.dereference()
X                #self._capacity = (impl + 1).dereference()
X                if hasattr(gdb.Type, 'alignof'):
X                    sizeof_Impl = max(2 * int_type.sizeof, cmpt_type.alignof)
X                else:
X                    sizeof_Impl = 2 * int_type.sizeof
X                begin = impl.cast(char_type.pointer()) + sizeof_Impl
X                self._item = begin.cast(cmpt_type.pointer())
X                self._finish = self._item + size
X                self._count = 0
X            else:
X                self._item = None
X                self._finish = None
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._item == self._finish:
X                raise StopIteration
X            item = self._item.dereference()
X            count = self._count
X            self._count = self._count + 1
X            self._item = self._item + 1
X            path = item['_M_pathname']
X            t = StdPathPrinter(self._pathtype, item)._path_type()
X            if not t:
X                t = count
X            return ('[%s]' % t, path)
X
X    def children(self):
X        return self._iterator(self._impl, self._typename)
X
X
class StdPairPrinter(printer_base):
X    """Print a std::pair object, with 'first' and 'second' as children."""
X
X    def __init__(self, typename, val):
X        self._val = val
X
X    class _iter(Iterator):
X        """An iterator for std::pair types. Returns 'first' then 'second'."""
X
X        def __init__(self, val):
X            self._val = val
X            self._which = 'first'
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._which is None:
X                raise StopIteration
X            which = self._which
X            if which == 'first':
X                self._which = 'second'
X            else:
X                self._which = None
X            return (which, self._val[which])
X
X    def children(self):
X        return self._iter(self._val)
X
X    def to_string(self):
X        return None
X
X
class StdCmpCatPrinter(printer_base):
X    """Print a comparison category object."""
X
X    def __init__(self, typename, val):
X        self._typename = typename[typename.rfind(':') + 1:]
X        self._val = val['_M_value']
X
X    def to_string(self):
X        if self._typename == 'strong_ordering' and self._val == 0:
X            name = 'equal'
X        else:
X            names = {2: 'unordered', -1: 'less', 0: 'equivalent', 1: 'greater'}
X            name = names[int(self._val)]
X        return 'std::{}::{}'.format(self._typename, name)
X
X
class StdErrorCodePrinter(printer_base):
X    """Print a std::error_code or std::error_condition."""
X
X    _system_is_posix = None  # Whether std::system_category() use errno values.
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = strip_versioned_namespace(typename)
X        # Do this only once ...
X        if StdErrorCodePrinter._system_is_posix is None:
X            try:
X                import posix
X                StdErrorCodePrinter._system_is_posix = True
X            except ImportError:
X                StdErrorCodePrinter._system_is_posix = False
X
X    @staticmethod
X    def _find_errc_enum(name):
X        typ = gdb.lookup_type(name)
X        if typ is not None and typ.code == gdb.TYPE_CODE_ENUM:
X            return typ
X        return None
X
X    @classmethod
X    def _find_standard_errc_enum(cls, name):
X        for ns in ['', _versioned_namespace]:
X            try:
X                qname = 'std::{}{}'.format(ns, name)
X                return cls._find_errc_enum(qname)
X            except RuntimeError:
X                pass
X
X    @classmethod
X    def _match_net_ts_category(cls, cat):
X        net_cats = ['stream', 'socket', 'ip::resolver']
X        for c in net_cats:
X            func = c + '_category()'
X            for ns in ['', _versioned_namespace]:
X                ns = 'std::{}experimental::net::v1'.format(ns)
X                sym = gdb.lookup_symbol('{}::{}::__c'.format(ns, func))[0]
X                if sym is not None:
X                    if cat == sym.value().address:
X                        name = 'net::' + func
X                        enum = cls._find_errc_enum('{}::{}_errc'.format(ns, c))
X                        return (name, enum)
X        return (None, None)
X
X    @classmethod
X    def _category_info(cls, cat):
X        """Return details of a std::error_category."""
X
X        name = None
X        enum = None
X        is_errno = False
X
X        # Try these first, or we get "warning: RTTI symbol not found" when
X        # using cat.dynamic_type on the local class types for Net TS
X        # categories.
X        func, enum = cls._match_net_ts_category(cat)
X        if func is not None:
X            return (None, func, enum, is_errno)
X
X        # This might give a warning for a program-defined category defined as
X        # a local class, but there doesn't seem to be any way to avoid that.
X        typ = cat.dynamic_type.target()
X        # Shortcuts for the known categories defined by libstdc++.
X        if typ.tag.endswith('::generic_error_category'):
X            name = 'generic'
X            is_errno = True
X        if typ.tag.endswith('::system_error_category'):
X            name = 'system'
X            is_errno = cls._system_is_posix
X        if typ.tag.endswith('::future_error_category'):
X            name = 'future'
X            enum = cls._find_standard_errc_enum('future_errc')
X        if typ.tag.endswith('::io_error_category'):
X            name = 'io'
X            enum = cls._find_standard_errc_enum('io_errc')
X
X        if name is None:
X            try:
X                # Want to call std::error_category::name() override, but it's
X                # unsafe: https://sourceware.org/bugzilla/show_bug.cgi?id=28856
X                # gdb.set_convenience_variable('__cat', cat)
X                # return '"%s"' % gdb.parse_and_eval('$__cat->name()').string()
X                pass
X            except:
X                pass
X        return (name, typ.tag, enum, is_errno)
X
X    @staticmethod
X    def _unqualified_name(name):
X        """
X        Strip any nested-name-specifier from name to give an unqualified name.
X        """
X        return name.split('::')[-1]
X
X    def to_string(self):
X        value = self._val['_M_value']
X        cat = self._val['_M_cat']
X        name, alt_name, enum, is_errno = self._category_info(cat)
X        if value == 0:
X            default_cats = {'error_code': 'system',
X                            'error_condition': 'generic'}
X            if name == default_cats[self._unqualified_name(self._typename)]:
X                return self._typename + ' = { }'  # default-constructed value
X
X        strval = str(value)
X        if is_errno and value != 0:
X            try:
X                strval = errno.errorcode[int(value)]
X            except:
X                pass
X        elif enum is not None:
X            strval = self._unqualified_name(str(value.cast(enum)))
X
X        if name is not None:
X            name = '"%s"' % name
X        else:
X            name = alt_name
X        return '%s = {%s: %s}' % (self._typename, name, strval)
X
X
class StdRegexStatePrinter(printer_base):
X    """Print a state node in the NFA for a std::regex."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = typename
X
X    def to_string(self):
X        opcode = str(self._val['_M_opcode'])
X        if opcode:
X            opcode = opcode[25:]
X        next_id = self._val['_M_next']
X
X        variants = {'repeat': 'alt', 'alternative': 'alt',
X                    'subexpr_begin': 'subexpr', 'subexpr_end': 'subexpr',
X                    'line_begin_assertion': None, 'line_end_assertion': None,
X                    'word_boundary': 'neg', 'subexpr_lookahead': 'neg',
X                    'backref': 'backref_index',
X                    'match': None, 'accept': None,
X                    'dummy': None, 'unknown': None
X                    }
X        v = variants[opcode]
X
X        s = "opcode={}, next={}".format(opcode, next_id)
X        if v is not None and self._val['_M_' + v] is not None:
X            s = "{}, {}={}".format(s, v, self._val['_M_' + v])
X        return "{%s}" % (s)
X
X
class StdSpanPrinter(printer_base):
X    """Print a std::span."""
X
X    class _iterator(Iterator):
X        def __init__(self, begin, size):
X            self._count = 0
X            self._begin = begin
X            self._size = size
X
X        def __iter__(self):
X            return self
X
X        def __next__(self):
X            if self._count == self._size:
X                raise StopIteration
X
X            count = self._count
X            self._count = self._count + 1
X            return '[%d]' % count, (self._begin + count).dereference()
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X        size_max = gdb.parse_and_eval('static_cast<std::size_t>(-1)')
X        if val.type.template_argument(1) == size_max:
X            self._size = val['_M_extent']['_M_extent_value']
X        else:
X            self._size = val.type.template_argument(1)
X
X    def to_string(self):
X        return '%s of length %d' % (self._typename, self._size)
X
X    def children(self):
X        return self._iterator(self._val['_M_ptr'], self._size)
X
X    def display_hint(self):
X        return 'array'
X
X
class StdInitializerListPrinter(printer_base):
X    """Print a std::initializer_list."""
X
X    def __init__(self, typename, val):
X        self._typename = typename
X        self._val = val
X        self._size = val['_M_len']
X
X    def to_string(self):
X        return '%s of length %d' % (self._typename, self._size)
X
X    def children(self):
X        return StdSpanPrinter._iterator(self._val['_M_array'], self._size)
X
X    def display_hint(self):
X        return 'array'
X
X
class StdAtomicPrinter(printer_base):
X    """Print a std:atomic."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X        self._shptr_printer = None
X        self._value_type = self._val.type.template_argument(0)
X        if self._value_type.tag is not None:
X            typ = strip_versioned_namespace(self._value_type.tag)
X            if (typ.startswith('std::shared_ptr<')
X                    or typ.startswith('std::weak_ptr<')):
X                impl = val['_M_impl']
X                self._shptr_printer = SharedPointerPrinter(typename, impl)
X                self.children = self._shptr_children
X
X    def _shptr_children(self):
X        return SmartPtrIterator(self._shptr_printer._pointer)
X
X    def to_string(self):
X        if self._shptr_printer is not None:
X            return self._shptr_printer.to_string()
X
X        if self._value_type.code == gdb.TYPE_CODE_INT:
X            val = self._val['_M_i']
X        elif self._value_type.code == gdb.TYPE_CODE_FLT:
X            val = self._val['_M_fp']
X        elif self._value_type.code == gdb.TYPE_CODE_PTR:
X            val = self._val['_M_b']['_M_p']
X        elif self._value_type.code == gdb.TYPE_CODE_BOOL:
X            val = self._val['_M_base']['_M_i']
X        else:
X            val = self._val['_M_i']
X        return '%s<%s> = { %s }' % (self._typename, str(self._value_type), val)
X
X
class StdFormatArgsPrinter(printer_base):
X    """Print a std::basic_format_args."""
X    # TODO: add printer for basic_format_arg<Context> and print out children.
X    # TODO: add printer for __format::_ArgStore<Context, Args...>.
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        targs = get_template_arg_list(self._val.type)
X        char_type = get_template_arg_list(targs[0])[1]
X        if char_type == gdb.lookup_type('char'):
X            typ = 'std::format_args'
X        elif char_type == gdb.lookup_type('wchar_t'):
X            typ = 'std::wformat_args'
X        else:
X            typ = 'std::basic_format_args'
X
X        size = self._val['_M_packed_size']
X        if size == 1:
X            return "%s with 1 argument" % (typ)
X        if size == 0:
X            size = self._val['_M_unpacked_size']
X        return "%s with %d arguments" % (typ, size)
X
X
class StdChronoDurationPrinter(printer_base):
X    """Print a std::chrono::duration."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def _ratio(self):
X        # TODO use reduced period i.e. duration::period
X        period = self._val.type.template_argument(1)
X        num = period.template_argument(0)
X        den = period.template_argument(1)
X        return (num, den)
X
X    def _suffix(self):
X        num, den = self._ratio()
X        if num == 1:
X            if den == 1:
X                return 's'
X            if den == 1000:
X                return 'ms'
X            if den == 1000000:
X                return 'us'
X            if den == 1000000000:
X                return 'ns'
X        elif den == 1:
X            if num == 60:
X                return 'min'
X            if num == 3600:
X                return 'h'
X            if num == 86400:
X                return 'd'
X            return '[{}]s'.format(num)
X        return "[{}/{}]s".format(num, den)
X
X    def to_string(self):
X        r = self._val['__r']
X        if r.type.strip_typedefs().code == gdb.TYPE_CODE_FLT:
X            r = "%g" % r
X        return "std::chrono::duration = {{ {}{} }}".format(r, self._suffix())
X
X
class StdChronoTimePointPrinter(printer_base):
X    """Print a std::chrono::time_point."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def _clock(self):
X        clock = self._val.type.template_argument(0)
X        name = strip_versioned_namespace(clock.name)
X        if name == 'std::chrono::_V2::system_clock' \
X                or name == 'std::chrono::system_clock':
X            return ('std::chrono::sys_time', 0)
X        # XXX need to remove leap seconds from utc, gps, and tai
X        if name == 'std::chrono::utc_clock':
X            return ('std::chrono::utc_time', None)  # XXX
X        if name == 'std::chrono::gps_clock':
X            return ('std::chrono::gps_time', None)  # XXX 315964809
X        if name == 'std::chrono::tai_clock':
X            return ('std::chrono::tai_time', None)  # XXX -378691210
X        if name == 'std::filesystem::__file_clock':
X            return ('std::chrono::file_time', 6437664000)
X        if name == 'std::chrono::local_t':
X            return ('std::chrono::local_time', 0)
X        return ('{} time_point'.format(name), None)
X
X    def to_string(self, abbrev=False):
X        clock, offset = self._clock()
X        d = self._val['__d']
X        r = d['__r']
X        printer = StdChronoDurationPrinter(d.type.name, d)
X        suffix = printer._suffix()
X        time = ''
X        if offset is not None:
X            num, den = printer._ratio()
X            secs = (r * num / den) + offset
X            try:
X                dt = datetime.datetime.fromtimestamp(secs, _utc_timezone)
X                time = ' [{:%Y-%m-%d %H:%M:%S}]'.format(dt)
X            except:
X                pass
X        s = '%d%s%s' % (r, suffix, time)
X        if abbrev:
X            return s
X        return '%s = { %s }' % (clock, s)
X
X
class StdChronoZonedTimePrinter(printer_base):
X    """Print a std::chrono::zoned_time."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        zone = self._val['_M_zone'].dereference()['_M_name']
X        time = self._val['_M_tp']
X        printer = StdChronoTimePointPrinter(time.type.name, time)
X        time = printer.to_string(True)
X        return 'std::chrono::zoned_time = {{ {} {} }}'.format(zone, time)
X
X
months = [None, 'January', 'February', 'March', 'April', 'May', 'June',
X          'July', 'August', 'September', 'October', 'November', 'December']
X
weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
X            'Saturday', 'Sunday']
X
X
class StdChronoCalendarPrinter(printer_base):
X    """Print a std::chrono::day, std::chrono::month, std::chrono::year etc."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        val = self._val
X        typ = self._typename
X        if 'month' in typ and typ != 'std::chrono::year_month_day_last':
X            m = val['_M_m']
X        if typ.startswith('std::chrono::year'):
X            y = val['_M_y']
X
X        if typ == 'std::chrono::day':
X            return '{}'.format(int(val['_M_d']))
X        if typ == 'std::chrono::month':
X            if m < 1 or m >= len(months):
X                return "%d is not a valid month" % m
X            return months[m]
X        if typ == 'std::chrono::year':
X            return '{}y'.format(y)
X        if typ == 'std::chrono::weekday':
X            wd = val['_M_wd']
X            if wd < 0 or wd >= len(weekdays):
X                return "%d is not a valid weekday" % wd
X            return '{}'.format(weekdays[wd])
X        if typ == 'std::chrono::weekday_indexed':
X            return '{}[{}]'.format(val['_M_wd'], int(val['_M_index']))
X        if typ == 'std::chrono::weekday_last':
X            return '{}[last]'.format(val['_M_wd'])
X        if typ == 'std::chrono::month_day':
X            return '{}/{}'.format(m, val['_M_d'])
X        if typ == 'std::chrono::month_day_last':
X            return '{}/last'.format(m)
X        if typ == 'std::chrono::month_weekday':
X            return '{}/{}'.format(m, val['_M_wdi'])
X        if typ == 'std::chrono::month_weekday_last':
X            return '{}/{}'.format(m, val['_M_wdl'])
X        if typ == 'std::chrono::year_month':
X            return '{}/{}'.format(y, m)
X        if typ == 'std::chrono::year_month_day':
X            return '{}/{}/{}'.format(y, m, val['_M_d'])
X        if typ == 'std::chrono::year_month_day_last':
X            return '{}/{}'.format(y, val['_M_mdl'])
X        if typ == 'std::chrono::year_month_weekday':
X            return '{}/{}/{}'.format(y, m, val['_M_wdi'])
X        if typ == 'std::chrono::year_month_weekday_last':
X            return '{}/{}/{}'.format(y, m, val['_M_wdl'])
X        if typ.startswith('std::chrono::hh_mm_ss'):
X            fract = ''
X            if val['fractional_width'] != 0:
X                fract = '.{:0{}d}'.format(int(val['_M_ss']['_M_r']),
X                                          int(val['fractional_width']))
X            h = int(val['_M_h']['__r'])
X            m = int(val['_M_m']['__r'])
X            s = int(val['_M_s']['__r'])
X            if val['_M_is_neg']:
X                h = -h
X            return '{:02}:{:02}:{:02}{}'.format(h, m, s, fract)
X
X
class StdChronoTimeZonePrinter(printer_base):
X    """Print a chrono::time_zone or chrono::time_zone_link."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        str = '%s = %s' % (self._typename, self._val['_M_name'])
X        if self._typename.endswith("_link"):
X            str += ' -> %s' % (self._val['_M_target'])
X        return str
X
X
class StdChronoLeapSecondPrinter(printer_base):
X    """Print a chrono::leap_second."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        date = self._val['_M_s']['__r']
X        neg = '+-'[date < 0]
X        return '%s %d (%c)' % (self._typename, abs(date), neg)
X
X
class StdChronoTzdbPrinter(printer_base):
X    """Print a chrono::tzdb."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        return '%s %s' % (self._typename, self._val['version'])
X
X
class StdChronoTimeZoneRulePrinter(printer_base):
X    """Print a chrono::time_zone rule."""
X
X    def __init__(self, typename, val):
X        self._typename = strip_versioned_namespace(typename)
X        self._val = val
X
X    def to_string(self):
X        on = self._val['on']
X        kind = on['kind']
X        month = months[on['month']]
X        suffixes = {1: 'st', 2: 'nd', 3: 'rd',
X                    21: 'st', 22: 'nd', 23: 'rd', 31: 'st'}
X        day = on['day_of_month']
X        ordinal_day = '{}{}'.format(day, suffixes.get(day, 'th'))
X        if kind == 0:  # DayOfMonth
X            start = '{} {}'.format(month, ordinal_day)
X        else:
X            weekday = weekdays[on['day_of_week']]
X            if kind == 1:  # LastWeekDay
X                start = 'last {} in {}'.format(weekday, month)
X            else:
X                if kind == 2:  # LessEq
X                    direction = ('last', '<=')
X                else:
X                    direction = ('first', '>=')
X                day = on['day_of_month']
X                start = '{} {} {} {} {}'.format(direction[0], weekday,
X                                                direction[1], month,
X                                                ordinal_day)
X        return 'time_zone rule {} from {} to {} starting on {}'.format(
X            self._val['name'], self._val['from'], self._val['to'], start)
X
X
class StdLocalePrinter(printer_base):
X    """Print a std::locale."""
X
X    def __init__(self, typename, val):
X        self._val = val
X        self._typename = typename
X
X    def to_string(self):
X        names = self._val['_M_impl']['_M_names']
X        mod = ''
X        if names[0] == 0:
X            name = '*'
X        else:
X            cats = gdb.parse_and_eval(self._typename + '::_S_categories')
X            ncat = gdb.parse_and_eval(self._typename + '::_S_categories_size')
X            n = names[0].string()
X            cat = cats[0].string()
X            name = '{}={}'.format(cat, n)
X            cat_names = {cat: n}
X            i = 1
X            while i < ncat and names[i] != 0:
X                n = names[i].string()
X                cat = cats[i].string()
X                name = '{};{}={}'.format(name, cat, n)
X                cat_names[cat] = n
X                i = i + 1
X            uniq_names = set(cat_names.values())
X            if len(uniq_names) == 1:
X                name = n
X            elif len(uniq_names) == 2:
X                n1, n2 = (uniq_names)
X                name_list = list(cat_names.values())
X                other = None
X                if name_list.count(n1) == 1:
X                    name = n2
X                    other = n1
X                elif name_list.count(n2) == 1:
X                    name = n1
X                    other = n2
X                if other is not None:
X                    cat = next(c for c, n in cat_names.items() if n == other)
X                    mod = ' with "{}={}"'.format(cat, other)
X        return 'std::locale = "{}"{}'.format(name, mod)
X
X
# A "regular expression" printer which conforms to the
# "SubPrettyPrinter" protocol from gdb.printing.
class RxPrinter(object):
X    def __init__(self, name, function):
X        super(RxPrinter, self).__init__()
X        self.name = name
X        self._function = function
X        self.enabled = True
X
X    def invoke(self, value):
X        if not self.enabled:
X            return None
X
X        if value.type.code == gdb.TYPE_CODE_REF:
X            if hasattr(gdb.Value, "referenced_value"):
X                value = value.referenced_value()
X
X        return self._function(self.name, value)
X
# A pretty-printer that conforms to the "PrettyPrinter" protocol from
# gdb.printing.  It can also be used directly as an old-style printer.
X
X
class Printer(object):
X    def __init__(self, name):
X        super(Printer, self).__init__()
X        self.name = name
X        self._subprinters = []
X        self._lookup = {}
X        self.enabled = True
X        self._compiled_rx = re.compile('^([a-zA-Z0-9_:]+)(<.*>)?$')
X
X    def add(self, name, function):
X        # A small sanity check.
X        # FIXME
X        if not self._compiled_rx.match(name):
X            raise ValueError(
X                'libstdc++ programming error: "%s" does not match' % name)
X        printer = RxPrinter(name, function)
X        self._subprinters.append(printer)
X        self._lookup[name] = printer
X
X    # Add a name using _GLIBCXX_BEGIN_NAMESPACE_VERSION.
X    def add_version(self, base, name, function):
X        self.add(base + name, function)
X        if '__cxx11' not in base:
X            vbase = re.sub('^(std|__gnu_cxx)::', r'\g<0>%s' %
X                           _versioned_namespace, base)
X            self.add(vbase + name, function)
X
X    # Add a name using _GLIBCXX_BEGIN_NAMESPACE_CONTAINER.
X    def add_container(self, base, name, function):
X        self.add_version(base, name, function)
X        self.add_version(base + '__cxx1998::', name, function)
X
X    @staticmethod
X    def get_basic_type(type):
X        # If it points to a reference, get the reference.
X        if type.code == gdb.TYPE_CODE_REF:
X            type = type.target()
X
X        # Get the unqualified type, stripped of typedefs.
X        type = type.unqualified().strip_typedefs()
X
X        return type.tag
X
X    def __call__(self, val):
X        typename = self.get_basic_type(val.type)
X        if not typename:
X            return None
X
X        # All the types we match are template types, so we can use a
X        # dictionary.
X        match = self._compiled_rx.match(typename)
X        if not match:
X            return None
X
X        basename = match.group(1)
X
X        if val.type.code == gdb.TYPE_CODE_REF:
X            if hasattr(gdb.Value, "referenced_value"):
X                val = val.referenced_value()
X
X        if basename in self._lookup:
X            return self._lookup[basename].invoke(val)
X
X        # Cannot find a pretty printer.  Return None.
X        return None
X
X
libstdcxx_printer = None
X
X
class TemplateTypePrinter(object):
X    """
X    A type printer for class templates with default template arguments.
X
X    Recognizes specializations of class templates and prints them without
X    any template arguments that use a default template argument.
X    Type printers are recursively applied to the template arguments.
X
X    e.g. replace 'std::vector<T, std::allocator<T> >' with 'std::vector<T>'.
X    """
X
X    def __init__(self, name, defargs):
X        self.name = name
X        self._defargs = defargs
X        self.enabled = True
X
X    class _recognizer(object):
X        """The recognizer class for TemplateTypePrinter."""
X
X        def __init__(self, name, defargs):
X            self.name = name
X            self._defargs = defargs
X            # self._type_obj = None
X
X        def recognize(self, type_obj):
X            """
X            If type_obj is a specialization of self.name that uses all the
X            default template arguments for the class template, then return
X            a string representation of the type without default arguments.
X            Otherwise, return None.
X            """
X
X            if type_obj.tag is None:
X                return None
X
X            if not type_obj.tag.startswith(self.name):
X                return None
X
X            template_args = get_template_arg_list(type_obj)
X            displayed_args = []
X            require_defaulted = False
X            for n in range(len(template_args)):
X                # The actual template argument in the type:
X                targ = template_args[n]
X                # The default template argument for the class template:
X                defarg = self._defargs.get(n)
X                if defarg is not None:
X                    # Substitute other template arguments into the default:
X                    defarg = defarg.format(*template_args)
X                    # Fail to recognize the type (by returning None)
X                    # unless the actual argument is the same as the default.
X                    try:
X                        if targ != gdb.lookup_type(defarg):
X                            return None
X                    except gdb.error:
X                        # Type lookup failed, just use string comparison:
X                        if targ.tag != defarg:
X                            return None
X                    # All subsequent args must have defaults:
X                    require_defaulted = True
X                elif require_defaulted:
X                    return None
X                else:
X                    # Recursively apply recognizers to the template argument
X                    # and add it to the arguments that will be displayed:
X                    displayed_args.append(self._recognize_subtype(targ))
X
X            # This assumes no class templates in the nested-name-specifier:
X            template_name = type_obj.tag[0:type_obj.tag.find('<')]
X            template_name = strip_inline_namespaces(template_name)
X
X            return template_name + '<' + ', '.join(displayed_args) + '>'
X
X        def _recognize_subtype(self, type_obj):
X            """Convert a gdb.Type to a string by applying recognizers,
X            or if that fails then simply converting to a string."""
X
X            if type_obj.code == gdb.TYPE_CODE_PTR:
X                return self._recognize_subtype(type_obj.target()) + '*'
X            if type_obj.code == gdb.TYPE_CODE_ARRAY:
X                type_str = self._recognize_subtype(type_obj.target())
X                if str(type_obj.strip_typedefs()).endswith('[]'):
X                    return type_str + '[]'  # array of unknown bound
X                return "%s[%d]" % (type_str, type_obj.range()[1] + 1)
X            if type_obj.code == gdb.TYPE_CODE_REF:
X                return self._recognize_subtype(type_obj.target()) + '&'
X            if hasattr(gdb, 'TYPE_CODE_RVALUE_REF'):
X                if type_obj.code == gdb.TYPE_CODE_RVALUE_REF:
X                    return self._recognize_subtype(type_obj.target()) + '&&'
X
X            type_str = gdb.types.apply_type_recognizers(
X                gdb.types.get_type_recognizers(), type_obj)
X            if type_str:
X                return type_str
X            return str(type_obj)
X
X    def instantiate(self):
X        """Return a recognizer object for this type printer."""
X        return self._recognizer(self.name, self._defargs)
X
X
def add_one_template_type_printer(obj, name, defargs):
X    """
X    Add a type printer for a class template with default template arguments.
X
X    Args:
X        name (str): The template-name of the class template.
X        defargs (dict int:string) The default template arguments.
X
X    Types in defargs can refer to the Nth template-argument using {N}
X    (with zero-based indices).
X
X    e.g. 'unordered_map' has these defargs:
X    { 2: 'std::hash<{0}>',
X      3: 'std::equal_to<{0}>',
X      4: 'std::allocator<std::pair<const {0}, {1}> >' }
X    """
X    printer = TemplateTypePrinter('std::' + name, defargs)
X    gdb.types.register_type_printer(obj, printer)
X
X    # Add type printer for same type in debug namespace:
X    printer = TemplateTypePrinter('std::__debug::' + name, defargs)
X    gdb.types.register_type_printer(obj, printer)
X
X    if '__cxx11' not in name:
X        # Add second type printer for same type in versioned namespace:
X        ns = 'std::' + _versioned_namespace
X        # PR 86112 Cannot use dict comprehension here:
X        defargs = dict((n, d.replace('std::', ns))
X                       for (n, d) in defargs.items())
X        printer = TemplateTypePrinter(ns + name, defargs)
X        gdb.types.register_type_printer(obj, printer)
X
X        # Add type printer for same type in debug namespace:
X        printer = TemplateTypePrinter('std::__debug::' + name, defargs)
X        gdb.types.register_type_printer(obj, printer)
X
X
class FilteringTypePrinter(object):
X    """
X    A type printer that uses typedef names for common template specializations.
X
X    Args:
X        template (str): The class template to recognize.
X        name (str): The typedef-name that will be used instead.
X        targ1 (str, optional): The first template argument. Defaults to None.
X
X    Checks if a specialization of the class template 'template' is the same type
X    as the typedef 'name', and prints it as 'name' instead.
X
X    e.g. if an instantiation of std::basic_istream<C, T> is the same type as
X    std::istream then print it as std::istream.
X
X    If targ1 is provided (not None), match only template specializations with
X    this type as the first template argument, e.g. if template='basic_string'
X    and targ1='char' then only match 'basic_string<char,...>' and not
X    'basic_string<wchar_t,...>'. This rejects non-matching specializations
X    more quickly, without needing to do GDB type lookups.
X    """
X
X    def __init__(self, template, name, targ1=None):
X        self._template = template
X        self.name = name
X        self._targ1 = targ1
X        self.enabled = True
X
X    class _recognizer(object):
X        """The recognizer class for FilteringTypePrinter."""
X
X        def __init__(self, template, name, targ1):
X            self._template = template
X            self.name = name
X            self._targ1 = targ1
X            self._type_obj = None
X
X        def recognize(self, type_obj):
X            """
X            If type_obj starts with self._template and is the same type as
X            self.name then return self.name, otherwise None.
X            """
X            if type_obj.tag is None:
X                return None
X
X            if self._type_obj is None:
X                if self._targ1 is not None:
X                    s = '{}<{}'.format(self._template, self._targ1)
X                    if not type_obj.tag.startswith(s):
X                        # Filter didn't match.
X                        return None
X                elif not type_obj.tag.startswith(self._template):
X                    # Filter didn't match.
X                    return None
X
X                try:
X                    self._type_obj = gdb.lookup_type(
X                        self.name).strip_typedefs()
X                except:
X                    pass
X
X            if self._type_obj is None:
X                return None
X
X            t1 = gdb.types.get_basic_type(self._type_obj)
X            t2 = gdb.types.get_basic_type(type_obj)
X            if t1 == t2:
X                return strip_inline_namespaces(self.name)
X
X            # Workaround ambiguous typedefs matching both std:: and
X            # std::__cxx11:: symbols.
X            if self._template.split('::')[-1] == 'basic_string':
X                s1 = self._type_obj.tag.replace('__cxx11::', '')
X                s2 = type_obj.tag.replace('__cxx11::', '')
X                if s1 == s2:
X                    return strip_inline_namespaces(self.name)
X
X            return None
X
X    def instantiate(self):
X        """Return a recognizer object for this type printer."""
X        return self._recognizer(self._template, self.name, self._targ1)
X
X
def add_one_type_printer(obj, template, name, targ1=None):
X    printer = FilteringTypePrinter('std::' + template, 'std::' + name, targ1)
X    gdb.types.register_type_printer(obj, printer)
X    if '__cxx11' not in template:
X        ns = 'std::' + _versioned_namespace
X        printer = FilteringTypePrinter(ns + template, ns + name, targ1)
X        gdb.types.register_type_printer(obj, printer)
X
X
def register_type_printers(obj):
X    global _use_type_printing
X
X    if not _use_type_printing:
X        return
X
X    # Add type printers for typedefs std::string, std::wstring etc.
X    for ch in (('', 'char'),
X               ('w', 'wchar_t'),
X               ('u8', 'char8_t'),
X               ('u16', 'char16_t'),
X               ('u32', 'char32_t')):
X        add_one_type_printer(obj, 'basic_string', ch[0] + 'string', ch[1])
X        add_one_type_printer(obj, '__cxx11::basic_string',
X                             ch[0] + 'string', ch[1])
X        # Typedefs for __cxx11::basic_string used to be in namespace __cxx11:
X        add_one_type_printer(obj, '__cxx11::basic_string',
X                             '__cxx11::' + ch[0] + 'string', ch[1])
X        add_one_type_printer(obj, 'basic_string_view',
X                             ch[0] + 'string_view', ch[1])
X
X    # Add type printers for typedefs std::istream, std::wistream etc.
X    for ch in (('', 'char'), ('w', 'wchar_t')):
X        for x in ('ios', 'streambuf', 'istream', 'ostream', 'iostream',
X                  'filebuf', 'ifstream', 'ofstream', 'fstream'):
X            add_one_type_printer(obj, 'basic_' + x, ch[0] + x, ch[1])
X        for x in ('stringbuf', 'istringstream', 'ostringstream',
X                  'stringstream'):
X            add_one_type_printer(obj, 'basic_' + x, ch[0] + x, ch[1])
X            # <sstream> types are in __cxx11 namespace, but typedefs aren't:
X            add_one_type_printer(obj, '__cxx11::basic_' + x, ch[0] + x, ch[1])
X
X    # Add type printers for typedefs regex, wregex, cmatch, wcmatch etc.
X    for abi in ('', '__cxx11::'):
X        for ch in (('', 'char'), ('w', 'wchar_t')):
X            add_one_type_printer(obj, abi + 'basic_regex',
X                                 abi + ch[0] + 'regex', ch[1])
X        for ch in ('c', 's', 'wc', 'ws'):
X            add_one_type_printer(
X                obj, abi + 'match_results', abi + ch + 'match')
X            for x in ('sub_match', 'regex_iterator', 'regex_token_iterator'):
X                add_one_type_printer(obj, abi + x, abi + ch + x)
X
X    # Note that we can't have a printer for std::wstreampos, because
X    # it is the same type as std::streampos.
X    add_one_type_printer(obj, 'fpos', 'streampos')
X
X    # Add type printers for <chrono> typedefs.
X    for dur in ('nanoseconds', 'microseconds', 'milliseconds', 'seconds',
X                'minutes', 'hours', 'days', 'weeks', 'years', 'months'):
X        add_one_type_printer(obj, 'chrono::duration', 'chrono::' + dur)
X
X    # Add type printers for <random> typedefs.
X    add_one_type_printer(obj, 'linear_congruential_engine', 'minstd_rand0')
X    add_one_type_printer(obj, 'linear_congruential_engine', 'minstd_rand')
X    add_one_type_printer(obj, 'mersenne_twister_engine', 'mt19937')
X    add_one_type_printer(obj, 'mersenne_twister_engine', 'mt19937_64')
X    add_one_type_printer(obj, 'subtract_with_carry_engine', 'ranlux24_base')
X    add_one_type_printer(obj, 'subtract_with_carry_engine', 'ranlux48_base')
X    add_one_type_printer(obj, 'discard_block_engine', 'ranlux24')
X    add_one_type_printer(obj, 'discard_block_engine', 'ranlux48')
X    add_one_type_printer(obj, 'shuffle_order_engine', 'knuth_b')
X
X    # Add type printers for experimental::basic_string_view typedefs.
X    ns = 'experimental::fundamentals_v1::'
X    for ch in (('', 'char'),
X               ('w', 'wchar_t'),
X               ('u8', 'char8_t'),
X               ('u16', 'char16_t'),
X               ('u32', 'char32_t')):
X        add_one_type_printer(obj, ns + 'basic_string_view',
X                             ns + ch[0] + 'string_view', ch[1])
X
X    # Do not show defaulted template arguments in class templates.
X    add_one_template_type_printer(obj, 'unique_ptr',
X                                  {1: 'std::default_delete<{0}>'})
X    add_one_template_type_printer(obj, 'deque', {1: 'std::allocator<{0}>'})
X    add_one_template_type_printer(
X        obj, 'forward_list', {1: 'std::allocator<{0}>'})
X    add_one_template_type_printer(obj, 'list', {1: 'std::allocator<{0}>'})
X    add_one_template_type_printer(
X        obj, '__cxx11::list', {1: 'std::allocator<{0}>'})
X    add_one_template_type_printer(obj, 'vector', {1: 'std::allocator<{0}>'})
X    add_one_template_type_printer(obj, 'map',
X                                  {2: 'std::less<{0}>',
X                                   3: 'std::allocator<std::pair<{0} const, {1}>>'})
X    add_one_template_type_printer(obj, 'multimap',
X                                  {2: 'std::less<{0}>',
X                                   3: 'std::allocator<std::pair<{0} const, {1}>>'})
X    add_one_template_type_printer(obj, 'set',
X                                  {1: 'std::less<{0}>', 2: 'std::allocator<{0}>'})
X    add_one_template_type_printer(obj, 'multiset',
X                                  {1: 'std::less<{0}>', 2: 'std::allocator<{0}>'})
X    add_one_template_type_printer(obj, 'unordered_map',
X                                  {2: 'std::hash<{0}>',
X                                   3: 'std::equal_to<{0}>',
X                                   4: 'std::allocator<std::pair<{0} const, {1}>>'})
X    add_one_template_type_printer(obj, 'unordered_multimap',
X                                  {2: 'std::hash<{0}>',
X                                   3: 'std::equal_to<{0}>',
X                                   4: 'std::allocator<std::pair<{0} const, {1}>>'})
X    add_one_template_type_printer(obj, 'unordered_set',
X                                  {1: 'std::hash<{0}>',
X                                   2: 'std::equal_to<{0}>',
X                                   3: 'std::allocator<{0}>'})
X    add_one_template_type_printer(obj, 'unordered_multiset',
X                                  {1: 'std::hash<{0}>',
X                                   2: 'std::equal_to<{0}>',
X                                   3: 'std::allocator<{0}>'})
X
X
def register_libstdcxx_printers(obj):
X    """Register libstdc++ pretty-printers with objfile Obj."""
X
X    global _use_gdb_pp
X    global libstdcxx_printer
X
X    if _use_gdb_pp:
X        gdb.printing.register_pretty_printer(obj, libstdcxx_printer)
X    else:
X        if obj is None:
X            obj = gdb
X        obj.pretty_printers.append(libstdcxx_printer)
X
X    register_type_printers(obj)
X
X
def build_libstdcxx_dictionary():
X    global libstdcxx_printer
X
X    libstdcxx_printer = Printer("libstdc++-v6")
X
X    # libstdc++ objects requiring pretty-printing.
X    # In order from:
X    # http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01847.html
X    libstdcxx_printer.add_version('std::', 'basic_string', StdStringPrinter)
X    libstdcxx_printer.add_version(
X        'std::__cxx11::', 'basic_string', StdStringPrinter)
X    libstdcxx_printer.add_container('std::', 'bitset', StdBitsetPrinter)
X    libstdcxx_printer.add_container('std::', 'deque', StdDequePrinter)
X    libstdcxx_printer.add_container('std::', 'list', StdListPrinter)
X    libstdcxx_printer.add_container('std::__cxx11::', 'list', StdListPrinter)
X    libstdcxx_printer.add_container('std::', 'map', StdMapPrinter)
X    libstdcxx_printer.add_container('std::', 'multimap', StdMapPrinter)
X    libstdcxx_printer.add_container('std::', 'multiset', StdSetPrinter)
X    libstdcxx_printer.add_version('std::', 'pair', StdPairPrinter)
X    libstdcxx_printer.add_version('std::', 'priority_queue',
X                                  StdStackOrQueuePrinter)
X    libstdcxx_printer.add_version('std::', 'queue', StdStackOrQueuePrinter)
X    libstdcxx_printer.add_version('std::', 'tuple', StdTuplePrinter)
X    libstdcxx_printer.add_container('std::', 'set', StdSetPrinter)
X    libstdcxx_printer.add_version('std::', 'stack', StdStackOrQueuePrinter)
X    libstdcxx_printer.add_version('std::', 'unique_ptr', UniquePointerPrinter)
X    libstdcxx_printer.add_container('std::', 'vector', StdVectorPrinter)
X    # vector<bool>
X    libstdcxx_printer.add_version('std::', 'locale', StdLocalePrinter)
X
X    if hasattr(gdb.Value, 'dynamic_type'):
X        libstdcxx_printer.add_version('std::', 'error_code',
X                                      StdErrorCodePrinter)
X        libstdcxx_printer.add_version('std::', 'error_condition',
X                                      StdErrorCodePrinter)
X
X    # Printer registrations for classes compiled with -D_GLIBCXX_DEBUG.
X    libstdcxx_printer.add('std::__debug::bitset', StdBitsetPrinter)
X    libstdcxx_printer.add('std::__debug::deque', StdDequePrinter)
X    libstdcxx_printer.add('std::__debug::list', StdListPrinter)
X    libstdcxx_printer.add('std::__debug::map', StdMapPrinter)
X    libstdcxx_printer.add('std::__debug::multimap', StdMapPrinter)
X    libstdcxx_printer.add('std::__debug::multiset', StdSetPrinter)
X    libstdcxx_printer.add('std::__debug::set', StdSetPrinter)
X    libstdcxx_printer.add('std::__debug::vector', StdVectorPrinter)
X
X    # These are the TR1 and C++11 printers.
X    # For array - the default GDB pretty-printer seems reasonable.
X    libstdcxx_printer.add_version('std::', 'shared_ptr', SharedPointerPrinter)
X    libstdcxx_printer.add_version('std::', 'weak_ptr', SharedPointerPrinter)
X    libstdcxx_printer.add_container('std::', 'unordered_map',
X                                    Tr1UnorderedMapPrinter)
X    libstdcxx_printer.add_container('std::', 'unordered_set',
X                                    Tr1UnorderedSetPrinter)
X    libstdcxx_printer.add_container('std::', 'unordered_multimap',
X                                    Tr1UnorderedMapPrinter)
X    libstdcxx_printer.add_container('std::', 'unordered_multiset',
X                                    Tr1UnorderedSetPrinter)
X    libstdcxx_printer.add_container('std::', 'forward_list',
X                                    StdForwardListPrinter)
X
X    libstdcxx_printer.add_version(
X        'std::tr1::', 'shared_ptr', SharedPointerPrinter)
X    libstdcxx_printer.add_version(
X        'std::tr1::', 'weak_ptr', SharedPointerPrinter)
X    libstdcxx_printer.add_version('std::tr1::', 'unordered_map',
X                                  Tr1UnorderedMapPrinter)
X    libstdcxx_printer.add_version('std::tr1::', 'unordered_set',
X                                  Tr1UnorderedSetPrinter)
X    libstdcxx_printer.add_version('std::tr1::', 'unordered_multimap',
X                                  Tr1UnorderedMapPrinter)
X    libstdcxx_printer.add_version('std::tr1::', 'unordered_multiset',
X                                  Tr1UnorderedSetPrinter)
X
X    libstdcxx_printer.add_version('std::', 'initializer_list',
X                                  StdInitializerListPrinter)
X    libstdcxx_printer.add_version('std::', 'atomic', StdAtomicPrinter)
X    libstdcxx_printer.add_version(
X        'std::', 'basic_stringbuf', StdStringBufPrinter)
X    libstdcxx_printer.add_version(
X        'std::__cxx11::', 'basic_stringbuf', StdStringBufPrinter)
X    for sstream in ('istringstream', 'ostringstream', 'stringstream'):
X        libstdcxx_printer.add_version(
X            'std::', 'basic_' + sstream, StdStringStreamPrinter)
X        libstdcxx_printer.add_version(
X            'std::__cxx11::', 'basic_' + sstream, StdStringStreamPrinter)
X
X    libstdcxx_printer.add_version('std::chrono::', 'duration',
X                                  StdChronoDurationPrinter)
X    libstdcxx_printer.add_version('std::chrono::', 'time_point',
X                                  StdChronoTimePointPrinter)
X
X    # std::regex components
X    libstdcxx_printer.add_version('std::__detail::', '_State',
X                                  StdRegexStatePrinter)
X
X    # These are the C++11 printer registrations for -D_GLIBCXX_DEBUG cases.
X    # The tr1 namespace containers do not have any debug equivalents,
X    # so do not register printers for them.
X    libstdcxx_printer.add('std::__debug::unordered_map',
X                          Tr1UnorderedMapPrinter)
X    libstdcxx_printer.add('std::__debug::unordered_set',
X                          Tr1UnorderedSetPrinter)
X    libstdcxx_printer.add('std::__debug::unordered_multimap',
X                          Tr1UnorderedMapPrinter)
X    libstdcxx_printer.add('std::__debug::unordered_multiset',
X                          Tr1UnorderedSetPrinter)
X    libstdcxx_printer.add('std::__debug::forward_list',
X                          StdForwardListPrinter)
X
X    # Library Fundamentals TS components
X    libstdcxx_printer.add_version('std::experimental::fundamentals_v1::',
X                                  'any', StdExpAnyPrinter)
X    libstdcxx_printer.add_version('std::experimental::fundamentals_v1::',
X                                  'optional', StdExpOptionalPrinter)
X    libstdcxx_printer.add_version('std::experimental::fundamentals_v1::',
X                                  'basic_string_view', StdExpStringViewPrinter)
X    # Filesystem TS components
X    libstdcxx_printer.add_version('std::experimental::filesystem::v1::',
X                                  'path', StdExpPathPrinter)
X    libstdcxx_printer.add_version('std::experimental::filesystem::v1::__cxx11::',
X                                  'path', StdExpPathPrinter)
X    libstdcxx_printer.add_version('std::filesystem::',
X                                  'path', StdPathPrinter)
X    libstdcxx_printer.add_version('std::filesystem::__cxx11::',
X                                  'path', StdPathPrinter)
X
X    # C++17 components
X    libstdcxx_printer.add_version('std::',
X                                  'any', StdExpAnyPrinter)
X    libstdcxx_printer.add_version('std::',
X                                  'optional', StdExpOptionalPrinter)
X    libstdcxx_printer.add_version('std::',
X                                  'basic_string_view', StdExpStringViewPrinter)
X    libstdcxx_printer.add_version('std::',
X                                  'variant', StdVariantPrinter)
X    libstdcxx_printer.add_version('std::',
X                                  '_Node_handle', StdNodeHandlePrinter)
X
X    # C++20 components
X    libstdcxx_printer.add_version(
X        'std::', 'partial_ordering', StdCmpCatPrinter)
X    libstdcxx_printer.add_version('std::', 'weak_ordering', StdCmpCatPrinter)
X    libstdcxx_printer.add_version('std::', 'strong_ordering', StdCmpCatPrinter)
X    libstdcxx_printer.add_version('std::', 'span', StdSpanPrinter)
X    libstdcxx_printer.add_version('std::', 'basic_format_args',
X                                  StdFormatArgsPrinter)
X    for c in ['day', 'month', 'year', 'weekday', 'weekday_indexed', 'weekday_last',
X              'month_day', 'month_day_last', 'month_weekday', 'month_weekday_last',
X              'year_month', 'year_month_day', 'year_month_day_last',
X              'year_month_weekday', 'year_month_weekday_last', 'hh_mm_ss']:
X        libstdcxx_printer.add_version('std::chrono::', c,
X                                      StdChronoCalendarPrinter)
X    libstdcxx_printer.add_version('std::chrono::', 'time_zone',
X                                  StdChronoTimeZonePrinter)
X    libstdcxx_printer.add_version('std::chrono::', 'time_zone_link',
X                                  StdChronoTimeZonePrinter)
X    libstdcxx_printer.add_version('std::chrono::', 'zoned_time',
X                                  StdChronoZonedTimePrinter)
X    libstdcxx_printer.add_version('std::chrono::', 'leap_second',
X                                  StdChronoLeapSecondPrinter)
X    libstdcxx_printer.add_version(
X        'std::chrono::', 'tzdb', StdChronoTzdbPrinter)
X    # libstdcxx_printer.add_version('std::chrono::(anonymous namespace)', 'Rule',
X    #                              StdChronoTimeZoneRulePrinter)
X
X    # Extensions.
X    libstdcxx_printer.add_version('__gnu_cxx::', 'slist', StdSlistPrinter)
X
X    if True:
X        # These shouldn't be necessary, if GDB "print *i" worked.
X        # But it often doesn't, so here they are.
X        libstdcxx_printer.add_container('std::', '_List_iterator',
X                                        StdListIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_List_const_iterator',
X                                        StdListIteratorPrinter)
X        libstdcxx_printer.add_version('std::', '_Rb_tree_iterator',
X                                      StdRbtreeIteratorPrinter)
X        libstdcxx_printer.add_version('std::', '_Rb_tree_const_iterator',
X                                      StdRbtreeIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Deque_iterator',
X                                        StdDequeIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Deque_const_iterator',
X                                        StdDequeIteratorPrinter)
X        libstdcxx_printer.add_version('__gnu_cxx::', '__normal_iterator',
X                                      StdVectorIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Bit_iterator',
X                                        StdBitIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Bit_const_iterator',
X                                        StdBitIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Bit_reference',
X                                        StdBitReferencePrinter)
X        libstdcxx_printer.add_version('__gnu_cxx::', '_Slist_iterator',
X                                      StdSlistIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Fwd_list_iterator',
X                                        StdFwdListIteratorPrinter)
X        libstdcxx_printer.add_container('std::', '_Fwd_list_const_iterator',
X                                        StdFwdListIteratorPrinter)
X
X        # Debug (compiled with -D_GLIBCXX_DEBUG) printer
X        # registrations.
X        libstdcxx_printer.add('__gnu_debug::_Safe_iterator',
X                              StdDebugIteratorPrinter)
X
X
build_libstdcxx_dictionary()
SHAR_EOF
  (set 20 26 02 15 11 19 14 'libstdc++-v3/python/libstdcxx/v6/printers.py'
   eval "${shar_touch}") && \
  chmod 0760 'libstdc++-v3/python/libstdcxx/v6/printers.py'
if test $? -ne 0
then ${echo} "restore of libstdc++-v3/python/libstdcxx/v6/printers.py failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'libstdc++-v3/python/libstdcxx/v6/printers.py': 'MD5 check failed'
       ) << \SHAR_EOF
25fca50ddaa1dca3dfd2c2fa6d6159c0  libstdc++-v3/python/libstdcxx/v6/printers.py
SHAR_EOF

else
test `LC_ALL=C wc -c < 'libstdc++-v3/python/libstdcxx/v6/printers.py'` -ne 110581 && \
  ${echo} "restoration warning:  size of 'libstdc++-v3/python/libstdcxx/v6/printers.py' is not 110581"
  fi
fi
# ============= libstdc++-v3/python/libstdcxx/v6/xmethods.py ==============
if test -n "${keep_file}" && test -f 'libstdc++-v3/python/libstdcxx/v6/xmethods.py'
then
${echo} "x - SKIPPING libstdc++-v3/python/libstdcxx/v6/xmethods.py (file already exists)"

else
${echo} "x - extracting libstdc++-v3/python/libstdcxx/v6/xmethods.py (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'libstdc++-v3/python/libstdcxx/v6/xmethods.py' &&
# Xmethods for libstdc++.
X
# Copyright (C) 2014-2023 Free Software Foundation, Inc.
X
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
X
import gdb
import gdb.xmethod
import re
X
matcher_name_prefix = 'libstdc++::'
X
X
def get_bool_type():
X    return gdb.lookup_type('bool')
X
def get_std_size_type():
X    return gdb.lookup_type('std::size_t')
X
_versioned_namespace = '__8::'
X
def is_specialization_of(x, template_name):
X    """
X    Test whether a type is a specialization of the named class template.
X    The type can be specified as a string or a gdb.Type object.
X    The template should be the name of a class template as a string,
X    without any 'std' qualification.
X    """
X    if isinstance(x, gdb.Type):
X        x = x.tag
X    template_name = '(%s)?%s' % (_versioned_namespace, template_name)
X    return re.match(r'^std::(__\d::)?%s<.*>$' % template_name, x) is not None
X
class LibStdCxxXMethod(gdb.xmethod.XMethod):
X    def __init__(self, name, worker_class):
X        gdb.xmethod.XMethod.__init__(self, name)
X        self.worker_class = worker_class
X
# Xmethods for std::array
X
X
class ArrayWorkerBase(gdb.xmethod.XMethodWorker):
X    def __init__(self, val_type, size):
X        self._val_type = val_type
X        self._size = size
X
X    def null_value(self):
X        nullptr = gdb.parse_and_eval('(void *) 0')
X        return nullptr.cast(self._val_type.pointer()).dereference()
X
X
class ArraySizeWorker(ArrayWorkerBase):
X    def __init__(self, val_type, size):
X        ArrayWorkerBase.__init__(self, val_type, size)
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return get_std_size_type()
X
X    def __call__(self, obj):
X        return self._size
X
X
class ArrayEmptyWorker(ArrayWorkerBase):
X    def __init__(self, val_type, size):
X        ArrayWorkerBase.__init__(self, val_type, size)
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return get_bool_type()
X
X    def __call__(self, obj):
X        return (int(self._size) == 0)
X
X
class ArrayFrontWorker(ArrayWorkerBase):
X    def __init__(self, val_type, size):
X        ArrayWorkerBase.__init__(self, val_type, size)
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        if int(self._size) > 0:
X            return obj['_M_elems'][0]
X        else:
X            return self.null_value()
X
X
class ArrayBackWorker(ArrayWorkerBase):
X    def __init__(self, val_type, size):
X        ArrayWorkerBase.__init__(self, val_type, size)
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        if int(self._size) > 0:
X            return obj['_M_elems'][self._size - 1]
X        else:
X            return self.null_value()
X
X
class ArrayAtWorker(ArrayWorkerBase):
X    def __init__(self, val_type, size):
X        ArrayWorkerBase.__init__(self, val_type, size)
X
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, index):
X        return self._val_type
X
X    def __call__(self, obj, index):
X        if int(index) >= int(self._size):
X            raise IndexError('Array index "%d" should not be >= %d.' %
X                             ((int(index), self._size)))
X        return obj['_M_elems'][index]
X
X
class ArraySubscriptWorker(ArrayWorkerBase):
X    def __init__(self, val_type, size):
X        ArrayWorkerBase.__init__(self, val_type, size)
X
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, index):
X        return self._val_type
X
X    def __call__(self, obj, index):
X        if int(self._size) > 0:
X            return obj['_M_elems'][index]
X        else:
X            return self.null_value()
X
X
class ArrayMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + 'array')
X        self._method_dict = {
X            'size': LibStdCxxXMethod('size', ArraySizeWorker),
X            'empty': LibStdCxxXMethod('empty', ArrayEmptyWorker),
X            'front': LibStdCxxXMethod('front', ArrayFrontWorker),
X            'back': LibStdCxxXMethod('back', ArrayBackWorker),
X            'at': LibStdCxxXMethod('at', ArrayAtWorker),
X            'operator[]': LibStdCxxXMethod('operator[]', ArraySubscriptWorker),
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, 'array'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        try:
X            value_type = class_type.template_argument(0)
X            size = class_type.template_argument(1)
X        except:
X            return None
X        return method.worker_class(value_type, size)
X
X
# Xmethods for std::deque
X
X
class DequeWorkerBase(gdb.xmethod.XMethodWorker):
X    def __init__(self, val_type):
X        self._val_type = val_type
X        self._bufsize = 512 // val_type.sizeof or 1
X
X    def size(self, obj):
X        start = obj['_M_impl']['_M_start']
X        finish = obj['_M_impl']['_M_finish']
X        if start['_M_cur'] == finish['_M_cur']:
X            return 0
X        return (self._bufsize
X                * (finish['_M_node'] - start['_M_node'] - 1)
X                + (finish['_M_cur'] - finish['_M_first'])
X                + (start['_M_last'] - start['_M_cur']))
X
X    def index(self, obj, idx):
X        start = obj['_M_impl']['_M_start']
X        first_node_size = start['_M_last'] - start['_M_cur']
X        if idx < first_node_size:
X            return start['_M_cur'][idx]
X        idx = idx - first_node_size
X        index_node = start['_M_node'][1 + int(idx) // self._bufsize]
X        return index_node[idx % self._bufsize]
X
X
class DequeEmptyWorker(DequeWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return get_bool_type()
X
X    def __call__(self, obj):
X        return (obj['_M_impl']['_M_start']['_M_cur'] ==
X                obj['_M_impl']['_M_finish']['_M_cur'])
X
X
class DequeSizeWorker(DequeWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return get_std_size_type()
X
X    def __call__(self, obj):
X        return self.size(obj)
X
X
class DequeFrontWorker(DequeWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        return obj['_M_impl']['_M_start']['_M_cur'][0]
X
X
class DequeBackWorker(DequeWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        if (obj['_M_impl']['_M_finish']['_M_cur'] ==
X                obj['_M_impl']['_M_finish']['_M_first']):
X            prev_node = obj['_M_impl']['_M_finish']['_M_node'] - 1
X            return prev_node[0][self._bufsize - 1]
X        else:
X            return obj['_M_impl']['_M_finish']['_M_cur'][-1]
X
X
class DequeSubscriptWorker(DequeWorkerBase):
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, subscript):
X        return self._val_type
X
X    def __call__(self, obj, subscript):
X        return self.index(obj, subscript)
X
X
class DequeAtWorker(DequeWorkerBase):
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, index):
X        return self._val_type
X
X    def __call__(self, obj, index):
X        deque_size = int(self.size(obj))
X        if int(index) >= deque_size:
X            raise IndexError('Deque index "%d" should not be >= %d.' %
X                             (int(index), deque_size))
X        else:
X            return self.index(obj, index)
X
X
class DequeMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + 'deque')
X        self._method_dict = {
X            'empty': LibStdCxxXMethod('empty', DequeEmptyWorker),
X            'size': LibStdCxxXMethod('size', DequeSizeWorker),
X            'front': LibStdCxxXMethod('front', DequeFrontWorker),
X            'back': LibStdCxxXMethod('back', DequeBackWorker),
X            'operator[]': LibStdCxxXMethod('operator[]', DequeSubscriptWorker),
X            'at': LibStdCxxXMethod('at', DequeAtWorker)
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, 'deque'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        return method.worker_class(class_type.template_argument(0))
X
# Xmethods for std::forward_list
X
X
class ForwardListWorkerBase(gdb.xmethod.XMethodMatcher):
X    def __init__(self, val_type, node_type):
X        self._val_type = val_type
X        self._node_type = node_type
X
X    def get_arg_types(self):
X        return None
X
X
class ForwardListEmptyWorker(ForwardListWorkerBase):
X    def get_result_type(self, obj):
X        return get_bool_type()
X
X    def __call__(self, obj):
X        return obj['_M_impl']['_M_head']['_M_next'] == 0
X
X
class ForwardListFrontWorker(ForwardListWorkerBase):
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        node = obj['_M_impl']['_M_head']['_M_next'].cast(self._node_type)
X        val_address = node['_M_storage']['_M_storage'].address
X        return val_address.cast(self._val_type.pointer()).dereference()
X
X
class ForwardListMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        matcher_name = matcher_name_prefix + 'forward_list'
X        gdb.xmethod.XMethodMatcher.__init__(self, matcher_name)
X        self._method_dict = {
X            'empty': LibStdCxxXMethod('empty', ForwardListEmptyWorker),
X            'front': LibStdCxxXMethod('front', ForwardListFrontWorker)
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, 'forward_list'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        val_type = class_type.template_argument(0)
X        node_type = gdb.lookup_type(str(class_type) + '::_Node').pointer()
X        return method.worker_class(val_type, node_type)
X
# Xmethods for std::list
X
X
class ListWorkerBase(gdb.xmethod.XMethodWorker):
X    def __init__(self, val_type, node_type):
X        self._val_type = val_type
X        self._node_type = node_type
X
X    def get_arg_types(self):
X        return None
X
X    def get_value_from_node(self, node):
X        node = node.dereference()
X        if node.type.fields()[1].name == '_M_data':
X            # C++03 implementation, node contains the value as a member
X            return node['_M_data']
X        # C++11 implementation, node stores value in __aligned_membuf
X        addr = node['_M_storage'].address
X        return addr.cast(self._val_type.pointer()).dereference()
X
X
class ListEmptyWorker(ListWorkerBase):
X    def get_result_type(self, obj):
X        return get_bool_type()
X
X    def __call__(self, obj):
X        base_node = obj['_M_impl']['_M_node']
X        if base_node['_M_next'] == base_node.address:
X            return True
X        else:
X            return False
X
X
class ListSizeWorker(ListWorkerBase):
X    def get_result_type(self, obj):
X        return get_std_size_type()
X
X    def __call__(self, obj):
X        begin_node = obj['_M_impl']['_M_node']['_M_next']
X        end_node = obj['_M_impl']['_M_node'].address
X        size = 0
X        while begin_node != end_node:
X            begin_node = begin_node['_M_next']
X            size += 1
X        return size
X
X
class ListFrontWorker(ListWorkerBase):
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        node = obj['_M_impl']['_M_node']['_M_next'].cast(self._node_type)
X        return self.get_value_from_node(node)
X
X
class ListBackWorker(ListWorkerBase):
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        prev_node = obj['_M_impl']['_M_node']['_M_prev'].cast(self._node_type)
X        return self.get_value_from_node(prev_node)
X
X
class ListMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + 'list')
X        self._method_dict = {
X            'empty': LibStdCxxXMethod('empty', ListEmptyWorker),
X            'size': LibStdCxxXMethod('size', ListSizeWorker),
X            'front': LibStdCxxXMethod('front', ListFrontWorker),
X            'back': LibStdCxxXMethod('back', ListBackWorker)
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, '(__cxx11::)?list'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        val_type = class_type.template_argument(0)
X        node_type = gdb.lookup_type(str(class_type) + '::_Node').pointer()
X        return method.worker_class(val_type, node_type)
X
# Xmethods for std::vector
X
X
class VectorWorkerBase(gdb.xmethod.XMethodWorker):
X    def __init__(self, val_type):
X        self._val_type = val_type
X
X    def size(self, obj):
X        if self._val_type.code == gdb.TYPE_CODE_BOOL:
X            start = obj['_M_impl']['_M_start']['_M_p']
X            finish = obj['_M_impl']['_M_finish']['_M_p']
X            finish_offset = obj['_M_impl']['_M_finish']['_M_offset']
X            bit_size = start.dereference().type.sizeof * 8
X            return (finish - start) * bit_size + finish_offset
X        else:
X            return obj['_M_impl']['_M_finish'] - obj['_M_impl']['_M_start']
X
X    def get(self, obj, index):
X        if self._val_type.code == gdb.TYPE_CODE_BOOL:
X            start = obj['_M_impl']['_M_start']['_M_p']
X            bit_size = start.dereference().type.sizeof * 8
X            valp = start + index // bit_size
X            offset = index % bit_size
X            return (valp.dereference() & (1 << offset)) > 0
X        else:
X            return obj['_M_impl']['_M_start'][index]
X
X
class VectorEmptyWorker(VectorWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return get_bool_type()
X
X    def __call__(self, obj):
X        return int(self.size(obj)) == 0
X
X
class VectorSizeWorker(VectorWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return get_std_size_type()
X
X    def __call__(self, obj):
X        return self.size(obj)
X
X
class VectorFrontWorker(VectorWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        return self.get(obj, 0)
X
X
class VectorBackWorker(VectorWorkerBase):
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._val_type
X
X    def __call__(self, obj):
X        return self.get(obj, int(self.size(obj)) - 1)
X
X
class VectorAtWorker(VectorWorkerBase):
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, index):
X        return self._val_type
X
X    def __call__(self, obj, index):
X        size = int(self.size(obj))
X        if int(index) >= size:
X            raise IndexError('Vector index "%d" should not be >= %d.' %
X                             ((int(index), size)))
X        return self.get(obj, int(index))
X
X
class VectorSubscriptWorker(VectorWorkerBase):
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, subscript):
X        return self._val_type
X
X    def __call__(self, obj, subscript):
X        return self.get(obj, int(subscript))
X
X
class VectorMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + 'vector')
X        self._method_dict = {
X            'size': LibStdCxxXMethod('size', VectorSizeWorker),
X            'empty': LibStdCxxXMethod('empty', VectorEmptyWorker),
X            'front': LibStdCxxXMethod('front', VectorFrontWorker),
X            'back': LibStdCxxXMethod('back', VectorBackWorker),
X            'at': LibStdCxxXMethod('at', VectorAtWorker),
X            'operator[]': LibStdCxxXMethod('operator[]',
X                                           VectorSubscriptWorker),
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, 'vector'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        return method.worker_class(class_type.template_argument(0))
X
# Xmethods for associative containers
X
X
class AssociativeContainerWorkerBase(gdb.xmethod.XMethodWorker):
X    def __init__(self, unordered):
X        self._unordered = unordered
X
X    def node_count(self, obj):
X        if self._unordered:
X            return obj['_M_h']['_M_element_count']
X        else:
X            return obj['_M_t']['_M_impl']['_M_node_count']
X
X    def get_arg_types(self):
X        return None
X
X
class AssociativeContainerEmptyWorker(AssociativeContainerWorkerBase):
X    def get_result_type(self, obj):
X        return get_bool_type()
X
X    def __call__(self, obj):
X        return int(self.node_count(obj)) == 0
X
X
class AssociativeContainerSizeWorker(AssociativeContainerWorkerBase):
X    def get_result_type(self, obj):
X        return get_std_size_type()
X
X    def __call__(self, obj):
X        return self.node_count(obj)
X
X
class AssociativeContainerMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self, name):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + name)
X        self._name = name
X        self._method_dict = {
X            'size': LibStdCxxXMethod('size', AssociativeContainerSizeWorker),
X            'empty': LibStdCxxXMethod('empty',
X                                      AssociativeContainerEmptyWorker),
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, self._name):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        unordered = 'unordered' in self._name
X        return method.worker_class(unordered)
X
# Xmethods for std::unique_ptr
X
X
class UniquePtrGetWorker(gdb.xmethod.XMethodWorker):
X    """
X    Implement std::unique_ptr<T>::get() and std::unique_ptr<T>::operator->().
X    """
X
X    def __init__(self, elem_type):
X        self._is_array = elem_type.code == gdb.TYPE_CODE_ARRAY
X        if self._is_array:
X            self._elem_type = elem_type.target()
X        else:
X            self._elem_type = elem_type
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._elem_type.pointer()
X
X    def _supports(self, method_name):
X        # operator-> is not supported for unique_ptr<T[]>
X        return method_name == 'get' or not self._is_array
X
X    def __call__(self, obj):
X        impl_type = obj.dereference().type.fields()[0].type.tag
X        # Check for new implementations first:
X        if is_specialization_of(impl_type, '__uniq_ptr_(data|impl)'):
X            tuple_member = obj['_M_t']['_M_t']
X        elif is_specialization_of(impl_type, 'tuple'):
X            tuple_member = obj['_M_t']
X        else:
X            return None
X        tuple_impl_type = tuple_member.type.fields()[0].type  # _Tuple_impl
X        tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base
X        head_field = tuple_head_type.fields()[0]
X        if head_field.name == '_M_head_impl':
X            return tuple_member.cast(tuple_head_type)['_M_head_impl']
X        elif head_field.is_base_class:
X            return tuple_member.cast(head_field.type)
X        else:
X            return None
X
X
class UniquePtrDerefWorker(UniquePtrGetWorker):
X    """Implement std::unique_ptr<T>::operator*()."""
X
X    def __init__(self, elem_type):
X        UniquePtrGetWorker.__init__(self, elem_type)
X
X    def get_result_type(self, obj):
X        return self._elem_type
X
X    def _supports(self, method_name):
X        # operator* is not supported for unique_ptr<T[]>
X        return not self._is_array
X
X    def __call__(self, obj):
X        return UniquePtrGetWorker.__call__(self, obj).dereference()
X
X
class UniquePtrSubscriptWorker(UniquePtrGetWorker):
X    """Implement std::unique_ptr<T>::operator[](size_t)."""
X
X    def __init__(self, elem_type):
X        UniquePtrGetWorker.__init__(self, elem_type)
X
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, index):
X        return self._elem_type
X
X    def _supports(self, method_name):
X        # operator[] is only supported for unique_ptr<T[]>
X        return self._is_array
X
X    def __call__(self, obj, index):
X        return UniquePtrGetWorker.__call__(self, obj)[index]
X
X
class UniquePtrMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + 'unique_ptr')
X        self._method_dict = {
X            'get': LibStdCxxXMethod('get', UniquePtrGetWorker),
X            'operator->': LibStdCxxXMethod('operator->', UniquePtrGetWorker),
X            'operator*': LibStdCxxXMethod('operator*', UniquePtrDerefWorker),
X            'operator[]': LibStdCxxXMethod('operator[]', UniquePtrSubscriptWorker),
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, 'unique_ptr'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        worker = method.worker_class(class_type.template_argument(0))
X        if worker._supports(method_name):
X            return worker
X        return None
X
# Xmethods for std::shared_ptr
X
X
class SharedPtrGetWorker(gdb.xmethod.XMethodWorker):
X    """
X    Implements std::shared_ptr<T>::get() and std::shared_ptr<T>::operator->().
X    """
X
X    def __init__(self, elem_type):
X        self._is_array = elem_type.code == gdb.TYPE_CODE_ARRAY
X        if self._is_array:
X            self._elem_type = elem_type.target()
X        else:
X            self._elem_type = elem_type
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return self._elem_type.pointer()
X
X    def _supports(self, method_name):
X        # operator-> is not supported for shared_ptr<T[]>
X        return method_name == 'get' or not self._is_array
X
X    def __call__(self, obj):
X        return obj['_M_ptr']
X
X
class SharedPtrDerefWorker(SharedPtrGetWorker):
X    """Implement std::shared_ptr<T>::operator*()."""
X
X    def __init__(self, elem_type):
X        SharedPtrGetWorker.__init__(self, elem_type)
X
X    def get_result_type(self, obj):
X        return self._elem_type
X
X    def _supports(self, method_name):
X        # operator* is not supported for shared_ptr<T[]>
X        return not self._is_array
X
X    def __call__(self, obj):
X        return SharedPtrGetWorker.__call__(self, obj).dereference()
X
X
class SharedPtrSubscriptWorker(SharedPtrGetWorker):
X    """Implement std::shared_ptr<T>::operator[](size_t)."""
X
X    def __init__(self, elem_type):
X        SharedPtrGetWorker.__init__(self, elem_type)
X
X    def get_arg_types(self):
X        return get_std_size_type()
X
X    def get_result_type(self, obj, index):
X        return self._elem_type
X
X    def _supports(self, method_name):
X        # operator[] is only supported for shared_ptr<T[]>
X        return self._is_array
X
X    def __call__(self, obj, index):
X        # Check bounds if _elem_type is an array of known bound
X        m = re.match(r'.*\[(\d+)]$', str(self._elem_type))
X        if m and index >= int(m.group(1)):
X            raise IndexError('shared_ptr<%s> index "%d" should not be >= %d.' %
X                             (self._elem_type, int(index), int(m.group(1))))
X        return SharedPtrGetWorker.__call__(self, obj)[index]
X
X
class SharedPtrUseCountWorker(gdb.xmethod.XMethodWorker):
X    """Implement std::shared_ptr<T>::use_count()."""
X
X    def __init__(self, elem_type):
X        pass
X
X    def get_arg_types(self):
X        return None
X
X    def get_result_type(self, obj):
X        return gdb.lookup_type('long')
X
X    def _supports(self, method_name):
X        return True
X
X    def __call__(self, obj):
X        refcounts = obj['_M_refcount']['_M_pi']
X        return refcounts['_M_use_count'] if refcounts else 0
X
X
class SharedPtrUniqueWorker(SharedPtrUseCountWorker):
X    """Implement std::shared_ptr<T>::unique()."""
X
X    def __init__(self, elem_type):
X        SharedPtrUseCountWorker.__init__(self, elem_type)
X
X    def get_result_type(self, obj):
X        return gdb.lookup_type('bool')
X
X    def __call__(self, obj):
X        return SharedPtrUseCountWorker.__call__(self, obj) == 1
X
X
class SharedPtrMethodsMatcher(gdb.xmethod.XMethodMatcher):
X    def __init__(self):
X        gdb.xmethod.XMethodMatcher.__init__(self,
X                                            matcher_name_prefix + 'shared_ptr')
X        self._method_dict = {
X            'get': LibStdCxxXMethod('get', SharedPtrGetWorker),
X            'operator->': LibStdCxxXMethod('operator->', SharedPtrGetWorker),
X            'operator*': LibStdCxxXMethod('operator*', SharedPtrDerefWorker),
X            'operator[]': LibStdCxxXMethod('operator[]', SharedPtrSubscriptWorker),
X            'use_count': LibStdCxxXMethod('use_count', SharedPtrUseCountWorker),
X            'unique': LibStdCxxXMethod('unique', SharedPtrUniqueWorker),
X        }
X        self.methods = [self._method_dict[m] for m in self._method_dict]
X
X    def match(self, class_type, method_name):
X        if not is_specialization_of(class_type, 'shared_ptr'):
X            return None
X        method = self._method_dict.get(method_name)
X        if method is None or not method.enabled:
X            return None
X        worker = method.worker_class(class_type.template_argument(0))
X        if worker._supports(method_name):
X            return worker
X        return None
X
X
def register_libstdcxx_xmethods(locus):
X    gdb.xmethod.register_xmethod_matcher(locus, ArrayMethodsMatcher())
X    gdb.xmethod.register_xmethod_matcher(locus, ForwardListMethodsMatcher())
X    gdb.xmethod.register_xmethod_matcher(locus, DequeMethodsMatcher())
X    gdb.xmethod.register_xmethod_matcher(locus, ListMethodsMatcher())
X    gdb.xmethod.register_xmethod_matcher(locus, VectorMethodsMatcher())
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('set'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('map'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('multiset'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('multimap'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('unordered_set'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('unordered_map'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('unordered_multiset'))
X    gdb.xmethod.register_xmethod_matcher(
X        locus, AssociativeContainerMethodsMatcher('unordered_multimap'))
X    gdb.xmethod.register_xmethod_matcher(locus, UniquePtrMethodsMatcher())
X    gdb.xmethod.register_xmethod_matcher(locus, SharedPtrMethodsMatcher())
SHAR_EOF
  (set 20 26 02 15 11 19 14 'libstdc++-v3/python/libstdcxx/v6/xmethods.py'
   eval "${shar_touch}") && \
  chmod 0760 'libstdc++-v3/python/libstdcxx/v6/xmethods.py'
if test $? -ne 0
then ${echo} "restore of libstdc++-v3/python/libstdcxx/v6/xmethods.py failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'libstdc++-v3/python/libstdcxx/v6/xmethods.py': 'MD5 check failed'
       ) << \SHAR_EOF
358ce01ad28bc23f412d6cca22c00026  libstdc++-v3/python/libstdcxx/v6/xmethods.py
SHAR_EOF

else
test `LC_ALL=C wc -c < 'libstdc++-v3/python/libstdcxx/v6/xmethods.py'` -ne 28943 && \
  ${echo} "restoration warning:  size of 'libstdc++-v3/python/libstdcxx/v6/xmethods.py' is not 28943"
  fi
fi
# ============= scripts/apt-cyg ==============
if test -n "${keep_file}" && test -f 'scripts/apt-cyg'
then
${echo} "x - SKIPPING scripts/apt-cyg (file already exists)"

else
${echo} "x - extracting scripts/apt-cyg (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'scripts/apt-cyg' &&
#!/bin/bash
# apt-cyg: install tool for Cygwin similar to debian apt-get
#
# The MIT License (MIT)
#
# Copyright (c) 2013 Trans-code Design
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
X
if [ ${BASH_VERSINFO}${BASH_VERSINFO[1]} -lt 42 ]
then
X  echo 'Bash version 4.2+ required'
X  exit
fi
X
usage="\
NAME
X  apt-cyg - package manager utility
X
SYNOPSIS
X  apt-cyg [operation] [options] [targets]
X
DESCRIPTION
X  apt-cyg is a package management utility that tracks installed packages on a
X  Cygwin system. Invoking apt-cyg involves specifying an operation with any
X  potential options and targets to operate on. A target is usually a package
X  name, file name, URL, or a search string. Targets can be provided as command
X  line arguments.
X
OPERATIONS
X  install
X    Install package(s).
X
X  remove
X    Remove package(s) from the system.
X
X  update
X    Download a fresh copy of the master package list (setup.ini) from the
X    server defined in setup.rc.
X
X  download
X    Retrieve package(s) from the server, but do not install/upgrade anything.
X
X  show
X    Display information on given package(s).
X
X  depends
X    Produce a dependency tree for a package.
X
X  rdepends
X    Produce a tree of packages that depend on the named package.
X
X  list
X    Search each locally-installed package for names that match regexp. If no
X    package names are provided in the command line, all installed packages will
X    be queried.
X
X  listall
X    This will search each package in the master package list (setup.ini) for
X    names that match regexp.
X
X  category
X    Display all packages that are members of a named category.
X
X  listfiles
X    List all files owned by a given package. Multiple packages can be specified
X    on the command line.
X
X  search
X    Search for downloaded packages that own the specified file(s). The path can
X    be relative or absolute, and one or more files can be specified.
X
X  searchall
X    Search cygwin.com to retrieve file information about packages. The provided
X    target is considered to be a filename and searchall will return the
X    package(s) which contain this file.
X
X  mirror
X    Set the mirror; a full URL to a location where the database, packages, and
X    signatures for this repository can be found. If no URL is provided, display
X    current mirror.
X
X  cache
X    Set the package cache directory. If a file is not found in cache directory,
X    it will be downloaded. Unix and Windows forms are accepted, as well as
X    absolute or regular paths. If no directory is provided, display current
X    cache.
X
OPTIONS
X  --nodeps
X    Specify this option to skip all dependency checks.
X
X  --version
X    Display version and exit.
"
X
version="\
apt-cyg version 1
X
The MIT License (MIT)
X
Copyright (c) 2005-9 Stephen Jungels
"
X
function wget {
X  if command wget -h &>/dev/null
X  then
X    command wget "$@"
X  else
X    warn wget is not installed, using lynx as fallback
X    set "${*: -1}"
X    lynx -source "$1" > "${1##*/}"
X  fi
}
X
function find-workspace {
X  # default working directory and mirror
X  
X  # work wherever setup worked last, if possible
X  cache=$(awk '
X  BEGIN {
X    RS = "\n\\<"
X    FS = "\n\t"
X  }
X  $1 == "last-cache" {
X    print $2
X  }
X  ' /etc/setup/setup.rc)
X
X  mirror=$(awk '
X  /last-mirror/ {
X    getline
X    print $1
X  }
X  ' /etc/setup/setup.rc)
X  mirrordir=$(sed '
X  s / %2f g
X  s : %3a g
X  ' <<< "$mirror")
X
X  mkdir -p "$cache/$mirrordir/$arch"
X  cd "$cache/$mirrordir/$arch"
X  if [ -e setup.ini ]
X  then
X    return 0
X  else
X    get-setup
X    return 1
X  fi
}
X
function get-setup {
X  touch setup.ini
X  mv setup.ini setup.ini-save
X  wget -N $mirror/$arch/setup.bz2
X  if [ -e setup.bz2 ]
X  then
X    bunzip2 setup.bz2
X    mv setup setup.ini
X    echo Updated setup.ini
X  else
X    echo Error updating setup.ini, reverting
X    mv setup.ini-save setup.ini
X  fi
}
X
function check-packages {
X  if [[ $pks ]]
X  then
X    return 0
X  else
X    echo No packages found.
X    return 1
X  fi
}
X
function warn {
X  printf '\e[1;31m%s\e[m\n' "$*" >&2
}
X
function apt-update {
X  if find-workspace
X  then
X    get-setup
X  fi
}
X
function apt-category {
X  check-packages
X  find-workspace
X  for pkg in "${pks[@]}"
X  do
X    awk '
X    $1 == "@" {
X      pck = $2
X    }
X    $1 == "category:" && $0 ~ query {
X      print pck
X    }
X    ' query="$pks" setup.ini
X  done
}
X
function apt-list {
X  local sbq
X  for pkg in "${pks[@]}"
X  do
X    let sbq++ && echo
X    awk 'NR>1 && $1~pkg && $0=$1' pkg="$pkg" /etc/setup/installed.db
X  done
X  let sbq && return
X  awk 'NR>1 && $0=$1' /etc/setup/installed.db
}
X
function apt-listall {
X  check-packages
X  find-workspace
X  local sbq
X  for pkg in "${pks[@]}"
X  do
X    let sbq++ && echo
X    awk '$1~pkg && $0=$1' RS='\n\n@ ' FS='\n' pkg="$pkg" setup.ini
X  done
}
X
function apt-listfiles {
X  check-packages
X  find-workspace
X  local pkg sbq
X  for pkg in "${pks[@]}"
X  do
X    (( sbq++ )) && echo
X    if [ ! -e /etc/setup/"$pkg".lst.gz ]
X    then
X      download "$pkg"
X    fi
X    gzip -cd /etc/setup/"$pkg".lst.gz
X  done
}
X
function apt-show {
X  find-workspace
X  check-packages
X  for pkg in "${pks[@]}"
X  do
X    (( notfirst++ )) && echo
X    awk '
X    $1 == query {
X      print
X      fd++
X    }
X    END {
X      if (! fd)
X        print "Unable to locate package " query
X    }
X    ' RS='\n\n@ ' FS='\n' query="$pkg" setup.ini
X  done
}
X
function apt-depends {
X  find-workspace
X  check-packages
X  for pkg in "${pks[@]}"
X  do
X    awk '
X    @include "join"
X    $1 == "@" {
X      apg = $2
X    }
X    $1 == "requires:" {
X      for (z=2; z<=NF; z++)
X        reqs[apg][z-1] = $z
X    }
X    END {
X      prpg(ENVIRON["pkg"])
X    }
X    function smartmatch(small, large,    values) {
X      for (each in large)
X        values[large[each]]
X      return small in values
X    }
X    function prpg(fpg) {
X      if (smartmatch(fpg, spath)) return
X      spath[length(spath)+1] = fpg
X      print join(spath, 1, length(spath), " > ")
X      if (isarray(reqs[fpg]))
X        for (each in reqs[fpg])
X          prpg(reqs[fpg][each])
X      delete spath[length(spath)]
X    }
X    ' setup.ini
X  done
}
X
function apt-rdepends {
X  find-workspace
X  for pkg in "${pks[@]}"
X  do
X    awk '
X    @include "join"
X    $1 == "@" {
X      apg = $2
X    }
X    $1 == "requires:" {
X      for (z=2; z<=NF; z++)
X        reqs[$z][length(reqs[$z])+1] = apg
X    }
X    END {
X      prpg(ENVIRON["pkg"])
X    }
X    function smartmatch(small, large,    values) {
X      for (each in large)
X        values[large[each]]
X      return small in values
X    }
X    function prpg(fpg) {
X      if (smartmatch(fpg, spath)) return
X      spath[length(spath)+1] = fpg
X      print join(spath, 1, length(spath), " < ")
X      if (isarray(reqs[fpg]))
X        for (each in reqs[fpg])
X          prpg(reqs[fpg][each])
X      delete spath[length(spath)]
X    }
X    ' setup.ini
X  done
}
X
function apt-download {
X  check-packages
X  find-workspace
X  local pkg sbq
X  for pkg in "${pks[@]}"
X  do
X    (( sbq++ )) && echo
X    download "$pkg"
X  done
}
X
function download {
X  local pkg digest digactual
X  pkg=$1
X  # look for package and save desc file
X
X  awk '$1 == pc' RS='\n\n@ ' FS='\n' pc=$pkg setup.ini > desc
X  if [ ! -s desc ]
X  then
X    echo Unable to locate package $pkg
X    exit 1
X  fi
X
X  # download and unpack the bz2 or xz file
X
X  # pick the latest version, which comes first
X  set -- $(awk '$1 == "install:"' desc)
X  if (( ! $# ))
X  then
X    echo 'Could not find "install" in package description: obsolete package?'
X    exit 1
X  fi
X
X  dn=$(dirname $2)
X  bn=$(basename $2)
X
X  # check the md5
X  digest=$4
X  case ${#digest} in
X   32) hash=md5sum    ;;
X  128) hash=sha512sum ;;
X  esac
X  mkdir -p "$cache/$mirrordir/$dn"
X  cd "$cache/$mirrordir/$dn"
X  if ! test -e $bn || ! $hash -c <<< "$digest $bn"
X  then
X    wget -O $bn $mirror/$dn/$bn
X    $hash -c <<< "$digest $bn" || exit
X  fi
X
X  tar tf $bn | gzip > /etc/setup/"$pkg".lst.gz
X  cd ~-
X  mv desc "$cache/$mirrordir/$dn"
X  echo $dn $bn > /tmp/dwn
}
X
function apt-search {
X  check-packages
X  echo Searching downloaded packages...
X  for pkg in "${pks[@]}"
X  do
X    key=$(type -P "$pkg" | sed s./..)
X    [[ $key ]] || key=$pkg
X    for manifest in /etc/setup/*.lst.gz
X    do
X      if gzip -cd $manifest | grep -q "$key"
X      then
X        package=$(sed '
X        s,/etc/setup/,,
X        s,.lst.gz,,
X        ' <<< $manifest)
X        echo $package
X      fi
X    done
X  done
}
X
function apt-searchall {
X  cd /tmp
X  for pkg in "${pks[@]}"
X  do
X    printf -v qs 'text=1&arch=%s&grep=%s' $arch "$pkg"
X    wget -O matches cygwin.com/cgi-bin2/package-grep.cgi?"$qs"
X    awk '
X    NR == 1 {next}
X    mc[$1]++ {next}
X    /-debuginfo-/ {next}
X    /^cygwin32-/ {next}
X    {print $1}
X    ' FS=-[[:digit:]] matches
X  done
}
X
function apt-install {
X  check-packages
X  find-workspace
X  local pkg dn bn requires wr package sbq script
X  for pkg in "${pks[@]}"
X  do
X
X  if grep -q "^$pkg " /etc/setup/installed.db
X  then
X    echo Package $pkg is already installed, skipping
X    continue
X  fi
X  (( sbq++ )) && echo
X  echo Installing $pkg
X
X  download $pkg
X  read dn bn </tmp/dwn
X  echo Unpacking...
X
X  cd "$cache/$mirrordir/$dn"
X  tar -x -C / -f $bn
X  # update the package database
X
X  awk '
X  ins != 1 && pkg < $1 {
X    print pkg, bz, 0
X    ins = 1
X  }
X  1
X  END {
X    if (ins != 1) print pkg, bz, 0
X  }
X  ' pkg="$pkg" bz=$bn /etc/setup/installed.db > /tmp/awk.$$
X  mv /etc/setup/installed.db /etc/setup/installed.db-save
X  mv /tmp/awk.$$ /etc/setup/installed.db
X
X  [ -v nodeps ] && continue
X  # recursively install required packages
X
X  requires=$(awk '$1=="requires", $0=$2' FS=': ' desc)
X  cd ~-
X  wr=0
X  if [[ $requires ]]
X  then
X    echo Package $pkg requires the following packages, installing:
X    echo $requires
X    for package in $requires
X    do
X      if grep -q "^$package " /etc/setup/installed.db
X      then
X        echo Package $package is already installed, skipping
X        continue
X      fi
X      apt-cyg install --noscripts $package || (( wr++ ))
X    done
X  fi
X  if (( wr ))
X  then
X    echo some required packages did not install, continuing
X  fi
X
X  # run all postinstall scripts
X
X  [ -v noscripts ] && continue
X  find /etc/postinstall -name '*.sh' | while read script
X  do
X    echo Running $script
X    $script
X    mv $script $script.done
X  done
X  echo Package $pkg installed
X
X  done
}
X
function apt-remove {
X  check-packages
X  cd /etc
X  cygcheck awk bash bunzip2 grep gzip mv sed tar xz > setup/essential.lst
X  for pkg in "${pks[@]}"
X  do
X
X  if ! grep -q "^$pkg " setup/installed.db
X  then
X    echo Package $pkg is not installed, skipping
X    continue
X  fi
X
X  if [ ! -e setup/"$pkg".lst.gz ]
X  then
X    warn Package manifest missing, cannot remove $pkg. Exiting
X    exit 1
X  fi
X  gzip -dk setup/"$pkg".lst.gz
X  awk '
X  NR == FNR {
X    if ($NF) ess[$NF]
X    next
X  }
X  $NF in ess {
X    exit 1
X  }
X  ' FS='[/\\\\]' setup/{essential,$pkg}.lst
X  esn=$?
X  if [ $esn = 0 ]
X  then
X    echo Removing $pkg
X    if [ -e preremove/"$pkg".sh ]
X    then
X      preremove/"$pkg".sh
X      rm preremove/"$pkg".sh
X    fi
X    mapfile dt < setup/"$pkg".lst
X    for each in ${dt[*]}
X    do
X      [ -f /$each ] && rm /$each
X    done
X    for each in ${dt[*]}
X    do
X      [ -d /$each ] && rmdir --i /$each
X    done
X    rm -f setup/"$pkg".lst.gz postinstall/"$pkg".sh.done
X    awk -i inplace '$1 != ENVIRON["pkg"]' setup/installed.db
X    echo Package $pkg removed
X  fi
X  rm setup/"$pkg".lst
X  if [ $esn = 1 ]
X  then
X    warn apt-cyg cannot remove package $pkg, exiting
X    exit 1
X  fi
X
X  done
}
X
function apt-mirror {
X  if [ "$pks" ]
X  then
X    awk -i inplace '
X    1
X    /last-mirror/ {
X      getline
X      print "\t" pks
X    }
X    ' pks="$pks" /etc/setup/setup.rc
X    echo Mirror set to "$pks".
X  else
X    awk '
X    /last-mirror/ {
X      getline
X      print $1
X    }
X    ' /etc/setup/setup.rc
X  fi
}
X
function apt-cache {
X  if [ "$pks" ]
X  then
X    vas=$(cygpath -aw "$pks")
X    awk -i inplace '
X    1
X    /last-cache/ {
X      getline
X      print "\t" vas
X    }
X    ' vas="${vas//\\/\\\\}" /etc/setup/setup.rc
X    echo Cache set to "$vas".
X  else
X    awk '
X    /last-cache/ {
X      getline
X      print $1
X    }
X    ' /etc/setup/setup.rc
X  fi
}
X
if [ -p /dev/stdin ]
then
X  mapfile -t pks
fi
X
# process options
until [ $# = 0 ]
do
X  case "$1" in
X
X    --nodeps)
X      nodeps=1
X      shift
X    ;;
X
X    --noscripts)
X      noscripts=1
X      shift
X    ;;
X
X    --version)
X      printf "$version"
X      exit
X    ;;
X
X    update)
X      command=$1
X      shift
X    ;;
X
X    list | cache  | remove | depends | listall  | download | listfiles |\
X    show | mirror | search | install | category | rdepends | searchall )
X      if [[ $command ]]
X      then
X        pks+=("$1")
X      else
X        command=$1
X      fi
X      shift
X    ;;
X
X    *)
X      pks+=("$1")
X      shift
X    ;;
X
X  esac
done
X
set -a
X
if type -t apt-$command | grep -q function
then
X  readonly arch=${HOSTTYPE/i6/x}
X  apt-$command
else
X  printf "$usage"
fi
SHAR_EOF
  (set 20 26 02 15 11 19 15 'scripts/apt-cyg'
   eval "${shar_touch}") && \
  chmod 0775 'scripts/apt-cyg'
if test $? -ne 0
then ${echo} "restore of scripts/apt-cyg failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'scripts/apt-cyg': 'MD5 check failed'
       ) << \SHAR_EOF
034378fe4711a009ee146b13e058bd48  scripts/apt-cyg
SHAR_EOF

else
test `LC_ALL=C wc -c < 'scripts/apt-cyg'` -ne 13765 && \
  ${echo} "restoration warning:  size of 'scripts/apt-cyg' is not 13765"
  fi
fi
# ============= man/byzanz-helper.1 ==============
if test ! -d 'man'; then
  mkdir 'man'
if test $? -eq 0
then ${echo} "x - created directory man."
else ${echo} "x - failed to create directory man."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'man/byzanz-helper.1'
then
${echo} "x - SKIPPING man/byzanz-helper.1 (file already exists)"

else
${echo} "x - extracting man/byzanz-helper.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/byzanz-helper.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "BYZANZ-HELPER 1"
X.TH BYZANZ-HELPER 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
byzanz\-helper \- Helper script to record an X\-Window with byzanz\-record
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBbyzanz-helper\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBbyzanz-helper\fR [\fBOPTIONS\fR] \fB\-o\fR \fIFILE\fR
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool helps record a specific \fBX11\fR window using \fBbyzanz-record\fR. When
run, the script will ask the user to pick the desired X\-Window using the mouse.
The recording will then start for the specified duration.
X.PP
Internally the script uses \fBxwininfo\fR to obtain the position and size of the
recorded video. These parameters are not updated while the video is recorded.
It the recorded window is moved it will leave the area of recording and be
only partially visible in the resulting video.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-o\fR \fIFILE\fR|\fB\-\-output\fR=\fIFILE\fR" 4
X.IX Item "-o FILE|--output=FILE"
Sets the output file for the recorded video.
X.IP "\fB\-t\fR \fIDURATION\fR|\fB\-\-duration\fR=\fIDURATION\fR" 4
X.IX Item "-t DURATION|--duration=DURATION"
Sets the recording duration in seconds. Default is 30 seconds.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
\&\fBbyzanz\-record\fR\|(1), \fBbyzanz\-playback\fR\|(1), \fBxwininfo\fR\|(1)
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2018 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the MIT license.
SHAR_EOF
  (set 20 26 02 15 11 19 15 'man/byzanz-helper.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/byzanz-helper.1'
if test $? -ne 0
then ${echo} "restore of man/byzanz-helper.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/byzanz-helper.1': 'MD5 check failed'
       ) << \SHAR_EOF
91875c2632ae32ed577f24a67d189672  man/byzanz-helper.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/byzanz-helper.1'` -ne 3233 && \
  ${echo} "restoration warning:  size of 'man/byzanz-helper.1' is not 3233"
  fi
fi
# ============= man/codefmt.1 ==============
if test ! -d 'man'; then
  mkdir 'man'
if test $? -eq 0
then ${echo} "x - created directory man."
else ${echo} "x - failed to create directory man."
     exit 1
fi
fi
if test -n "${keep_file}" && test -f 'man/codefmt.1'
then
${echo} "x - SKIPPING man/codefmt.1 (file already exists)"

else
${echo} "x - extracting man/codefmt.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/codefmt.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "CODEFMT 1"
X.TH CODEFMT 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
codefmt \- Code Formatter tool
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBcodefmt\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBcodefmt\fR [\fBOPTIONS\fR] [\fBFILE\fR ...]
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool format tabular data into fixed size columns.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-e\fR \fIEOL-SEPARATOR\fR|\fB\-\-eol\fR=\fIEOL-SEPARATOR\fR" 4
X.IX Item "-e EOL-SEPARATOR|--eol=EOL-SEPARATOR"
Sets the end-of-line separator. Default value is: \f(CW\*(C` \e\e\*(C'\fR.
X.IP "\fB\-s\fR \fICOLUMN-SEPARATOR\fR|\fB\-\-separator\fR=\fICOLUMN-SEPARATOR\fR" 4
X.IX Item "-s COLUMN-SEPARATOR|--separator=COLUMN-SEPARATOR"
Sets the end-of-line separator. Default value is: \f(CW\*(C` \*(C'\fR.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
\&\fBfmt\fR\|(1), \fBcolumn\fR\|(1), \fBcodemv\fR\|(1)
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2019 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the GPL license.
SHAR_EOF
  (set 20 26 02 15 11 19 15 'man/codefmt.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/codefmt.1'
if test $? -ne 0
then ${echo} "restore of man/codefmt.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/codefmt.1': 'MD5 check failed'
       ) << \SHAR_EOF
8f9cf1e309f9bf9a5000e3863e4ec035  man/codefmt.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/codefmt.1'` -ne 2788 && \
  ${echo} "restoration warning:  size of 'man/codefmt.1' is not 2788"
  fi
fi
# ============= man/codemv.1 ==============
if test -n "${keep_file}" && test -f 'man/codemv.1'
then
${echo} "x - SKIPPING man/codemv.1 (file already exists)"

else
${echo} "x - extracting man/codemv.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/codemv.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "CODEMV 1"
X.TH CODEMV 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
codemv \- Code Mover Tool
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBcodemv\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBcodemv\fR [\fBOPTIONS\fR]...
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool divert part of its input to a specified file.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-a\fR \fIFILE\fR|\fB\-\-append\fR=\fIFILE\fR" 4
X.IX Item "-a FILE|--append=FILE"
Sets the file where diverted input is appended. This option is mutually
exclusive with the \fB\-o\fR option.
X.IP \fB\-c\fR|\fB\-\-copy\fR 4
X.IX Item "-c|--copy"
Copy to stdout the whole input.
X.IP "\fB\-o\fR \fIFILE\fR|\fB\-\-overwrite\fR=\fIFILE\fR" 4
X.IX Item "-o FILE|--overwrite=FILE"
Sets the file overwritten by the diverted input. This option is mutually
exclusive with the \fB\-o\fR option.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
\&\fBfmt\fR\|(1), \fBcolumn\fR\|(1), \fBcodefmt\fR\|(1)
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2019 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the GPL license.
SHAR_EOF
  (set 20 26 02 15 11 19 15 'man/codemv.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/codemv.1'
if test $? -ne 0
then ${echo} "restore of man/codemv.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/codemv.1': 'MD5 check failed'
       ) << \SHAR_EOF
799da18c0168c333c919fc0aa2a306b6  man/codemv.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/codemv.1'` -ne 2846 && \
  ${echo} "restoration warning:  size of 'man/codemv.1' is not 2846"
  fi
fi
# ============= man/ffmpeg-helper.1 ==============
if test -n "${keep_file}" && test -f 'man/ffmpeg-helper.1'
then
${echo} "x - SKIPPING man/ffmpeg-helper.1 (file already exists)"

else
${echo} "x - extracting man/ffmpeg-helper.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/ffmpeg-helper.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "FFMPEG-HELPER 1"
X.TH FFMPEG-HELPER 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
ffmpeg\-helper \- Helper script to record an X\-Window with ffmpeg\-record
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBffmpeg-helper\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBffmpeg-helper\fR [\fBOPTIONS\fR] \fB\-o\fR \fIFILE\fR
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool helps record a specific \fBX11\fR window using \fBffmpeg\fR. When
run, the script will ask the user to pick the desired X\-Window using the mouse.
The recording will then start for the specified duration.
X.PP
Internally the script uses \fBxwininfo\fR to obtain the position and size of the
recorded video. These parameters are not updated while the video is recorded.
It the recorded window is moved it will leave the area of recording and be
only partially visible in the resulting video.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-o\fR \fIFILE\fR|\fB\-\-output\fR=\fIFILE\fR" 4
X.IX Item "-o FILE|--output=FILE"
Sets the output file for the recorded video.
X.IP "\fB\-t\fR \fIDURATION\fR|\fB\-\-duration\fR=\fIDURATION\fR" 4
X.IX Item "-t DURATION|--duration=DURATION"
Sets the recording duration in seconds. Default is 30 seconds.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
\&\fBffmpeg\fR\|(1), \fBxwininfo\fR\|(1)
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2018 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the MIT license.
SHAR_EOF
  (set 20 26 02 15 11 19 15 'man/ffmpeg-helper.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/ffmpeg-helper.1'
if test $? -ne 0
then ${echo} "restore of man/ffmpeg-helper.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/ffmpeg-helper.1': 'MD5 check failed'
       ) << \SHAR_EOF
5a5339ce32411ec19aa7b7c9f5eba61e  man/ffmpeg-helper.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/ffmpeg-helper.1'` -ne 3189 && \
  ${echo} "restoration warning:  size of 'man/ffmpeg-helper.1' is not 3189"
  fi
fi
# ============= man/hyper-v.1 ==============
if test -n "${keep_file}" && test -f 'man/hyper-v.1'
then
${echo} "x - SKIPPING man/hyper-v.1 (file already exists)"

else
${echo} "x - extracting man/hyper-v.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/hyper-v.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "HYPER-V 1"
X.TH HYPER-V 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
hyper\-v \- Starts and stop the hyper\-v windows hypervisor
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBhyper-v\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBhyper-v\fR \-\-start
X.PP
\&\fBhyper-v\fR \-\-stop
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tools enables or disables the hyper-v service on Windows 10. Note that for
the change to take effect one has to reboot the computer.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP \fBstart\fR 4
X.IX Item "start"
Mark the hyper-v service as running the next time windows starts.
X.IP \fBstop\fR 4
X.IX Item "stop"
Mark the hyper-v service as not running the next time windows starts.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2018 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the MIT license.
SHAR_EOF
  (set 20 26 02 15 11 19 16 'man/hyper-v.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/hyper-v.1'
if test $? -ne 0
then ${echo} "restore of man/hyper-v.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/hyper-v.1': 'MD5 check failed'
       ) << \SHAR_EOF
6cf70a8bc3297306c699c914eb507dfc  man/hyper-v.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/hyper-v.1'` -ne 2645 && \
  ${echo} "restoration warning:  size of 'man/hyper-v.1' is not 2645"
  fi
fi
# ============= man/msvc-shell.1 ==============
if test -n "${keep_file}" && test -f 'man/msvc-shell.1'
then
${echo} "x - SKIPPING man/msvc-shell.1 (file already exists)"

else
${echo} "x - extracting man/msvc-shell.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/msvc-shell.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "MSVC-SHELL 1"
X.TH MSVC-SHELL 1 2026-02-15 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
msvc\-shell \- MS\-VC++ build environment shell spawner
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBmsvc-shell\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBmsvc-shell\fR [\fBOPTIONS\fR] \fBVC_OPTIONS\fR
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool wraps the \fBvcvarsall.bat\fR batch script provided with visual studio
to setup the build environment. Calling this script allows to spawn a shell
with the same configuration that \fBvcvarsall.bat\fR setup when called in a
windows console.
X.PP
The tool also setup a \fBVS_KIT\fR environment variable in the spawned shell to
indicate the parameters that were passed to \fBvcvarsall.bat\fR.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-p\fR \fIpath/to/vcvarsall.bat\fR|\fB\-\-vcvarsall\-path\fR=\fIpath/to/vcvarsall.bat\fR" 4
X.IX Item "-p path/to/vcvarsall.bat|--vcvarsall-path=path/to/vcvarsall.bat"
Sets the path to the \fBvcvarsall.bat\fR batch script. Before Visual Studio 2017
it was possible to deduce the path to this script from the environment variable
set at install time, but this is no longer the case.
X.SH VC_OPTIONS
X.IX Header "VC_OPTIONS"
The \fBvcvarsall.bat\fR script accepts parameters to indicate which architecture,
platform, SDK, etc. is targeted by the environment it sets up.
X.PP
Run the script without \fBVC_OPTIONS\fR to get more information in the error
message printed by \fBvcvarsall.bat\fR.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2017\-2026 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the GPL license.
SHAR_EOF
  (set 20 26 02 15 13 12 03 'man/msvc-shell.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/msvc-shell.1'
if test $? -ne 0
then ${echo} "restore of man/msvc-shell.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/msvc-shell.1': 'MD5 check failed'
       ) << \SHAR_EOF
6395b89762b5bc66a522b660ff1ef126  man/msvc-shell.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/msvc-shell.1'` -ne 3404 && \
  ${echo} "restoration warning:  size of 'man/msvc-shell.1' is not 3404"
  fi
fi
# ============= man/plgen.1 ==============
if test -n "${keep_file}" && test -f 'man/plgen.1'
then
${echo} "x - SKIPPING man/plgen.1 (file already exists)"

else
${echo} "x - extracting man/plgen.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/plgen.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "PLGEN 1"
X.TH PLGEN 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
plgen \- Code Formatter tool
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBplgen\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBplgen\fR [\fBOPTIONS\fR] \-c \fBFILE\fR
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool format tabular data into fixed size columns.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-c\fR \fIFILE\fR" 4
X.IX Item "-c FILE"
Sets the input file to compile.
X.IP "\fB\-o\fR \fIOUTPUT\fR" 4
X.IX Item "-o OUTPUT"
Sets the output file to generate.
X.SH "INPUT FILE FORMAT"
X.IX Header "INPUT FILE FORMAT"
The input file describe a simple data record. The file format is line oriented
and should start with a header:
X.PP
X.Vb 8
\&    :class\-name: The::Class::Name
\&    :version: 0.0.2a
\&    # Some comment
\&    #
\&    # Field       Default\-Value   Item\-Type_opt
\&    field\-name\-1  \*(Aq\*(Aq
\&    field\-name\-2  []              Item::Type
\&    field\-name\-3  0
X.Ve
X.PP
The following methods are created for scalar fields:
X.IP \fBget_field_name()\fR 5
X.IX Item "get_field_name()"
Gets the scalar value of the field.
X.ie n .IP set_field_name(\fR\fI$new_value\fR\fI\fR) 5
X.el .IP set_field_name(\fR\f(CI$new_value\fR\fI\fR) 5
X.IX Item "set_field_name($new_value)"
Sets the scalar value of the new field.
X.PP
For array fields, the following methods are created:
X.IP \fBcount_field_name()\fR 5
X.IX Item "count_field_name()"
Returns the count of elements in the array.
X.IP \fBget_field_name()\fR 5
X.IX Item "get_field_name()"
Which returns a list.
X.ie n .IP set_field_name(\fR\fI@new_values\fR\fI\fR) 5
X.el .IP set_field_name(\fR\f(CI@new_values\fR\fI\fR) 5
X.IX Item "set_field_name(@new_values)"
Which copies the items in the internal array.
X.ie n .IP push_field_name(\fR\fI@new_values\fR\fI\fR) 5
X.el .IP push_field_name(\fR\f(CI@new_values\fR\fI\fR) 5
X.IX Item "push_field_name(@new_values)"
Which append items to the internal array.
X.IP \fBclear_field_name()\fR 5
X.IX Item "clear_field_name()"
Which clears the internal array.
X.IP "apply_field_name(\fIsub {...}\fR)" 5
X.IX Item "apply_field_name(sub {...})"
Which applies the sub on the array's items.
X.SH DIAGNOSTICS
X.IX Header "DIAGNOSTICS"
X.SH "CONFIGURATION AND ENVIRONMENT"
X.IX Header "CONFIGURATION AND ENVIRONMENT"
X.SH DEPENDENCIES
X.IX Header "DEPENDENCIES"
X.SH INCOMPATIBILITIES
X.IX Header "INCOMPATIBILITIES"
X.SH "BUGS AND LIMITATIONS"
X.IX Header "BUGS AND LIMITATIONS"
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2019 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the GPL license.
SHAR_EOF
  (set 20 26 02 15 11 19 16 'man/plgen.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/plgen.1'
if test $? -ne 0
then ${echo} "restore of man/plgen.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/plgen.1': 'MD5 check failed'
       ) << \SHAR_EOF
f80118b0cb16d6ec4654e411b383feda  man/plgen.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/plgen.1'` -ne 4366 && \
  ${echo} "restoration warning:  size of 'man/plgen.1' is not 4366"
  fi
fi
# ============= man/sixel2tmux.1 ==============
if test -n "${keep_file}" && test -f 'man/sixel2tmux.1'
then
${echo} "x - SKIPPING man/sixel2tmux.1 (file already exists)"

else
${echo} "x - extracting man/sixel2tmux.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/sixel2tmux.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "SIXEL2TMUX 1"
X.TH SIXEL2TMUX 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
sixel2tmux \- Script converting sixel input into tmux's DCS escape sequence
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fBsixel2tmux\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fBsixel2tmux\fR [\fBOPTIONS\fR]
X.PP
GNUTERM=sixelgd gnuplot \-e 'plot sin(x)' | \fBsixel2tmux\fR
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool converts standard input into a \fItmux\fR specific \fBDCS\fR escape sequence
and outputs it to a terminal.
X.PP
The output of the program should be directed to a terminal. In case no terminal
is specified, the script will use \fI/dev/tty\fR.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-t\fR \fITERMINAL\fR|\fB\-\-terminal\fR=\fITERMINAL\fR" 4
X.IX Item "-t TERMINAL|--terminal=TERMINAL"
Sets the terminal used to output the tmux DCS escape sequence. In case the
terminal is not specified, the default value is: \fI/dev/tty\fR.
X.Sp
The special name: '\-' means \fIstdout\fR
X.IP \fB\-l\fR=\fIINCEPTION\fR|\fB\-\-inception\-level\fR=\fIINCEPTION\fR 4
X.IX Item "-l=INCEPTION|--inception-level=INCEPTION"
Sets the \fBtmux\fR inception level. This is needed in case you connect to another
\&\fBtmux\fR session from within a \fBtmux\fR session. Default value is 0 unless the
\&\fBTMUX\fR environment variable is set, in which case the default value is 1.
X.SH "ENVIRONMENT VARIABLES"
X.IX Header "ENVIRONMENT VARIABLES"
X.IP TMUX 4
X.IX Item "TMUX"
The \fBTMUX\fR environment variable is used to find out if we are running inside
a \fBtmux\fR pane.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
\&\fBxterm\fR\|(1), \fBtmux\fR\|(1)
X.IP "\fIXTerm Control Sequences\fR" 4
X.IX Item "XTerm Control Sequences"
X.Vb 1
\&    https://invisible\-island.net/xterm/ctlseqs/ctlseqs.html#h2\-Operating\-System\-Commands
X.Ve
X.IP "\fIDevice Control String Sequences\fR" 4
X.IX Item "Device Control String Sequences"
X.Vb 1
\&    https://vt100.net/docs/vt510\-rm/chapter4.html
X.Ve
X.IP "\fITMux DCS Sequences\fR" 4
X.IX Item "TMux DCS Sequences"
X.Vb 1
\&    see tmux changelog
X.Ve
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2017 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the MIT license.
SHAR_EOF
  (set 20 26 02 15 11 19 16 'man/sixel2tmux.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/sixel2tmux.1'
if test $? -ne 0
then ${echo} "restore of man/sixel2tmux.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/sixel2tmux.1': 'MD5 check failed'
       ) << \SHAR_EOF
44ad3e19085f55a91ff7af37dd100604  man/sixel2tmux.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/sixel2tmux.1'` -ne 3949 && \
  ${echo} "restoration warning:  size of 'man/sixel2tmux.1' is not 3949"
  fi
fi
# ============= man/yank.1 ==============
if test -n "${keep_file}" && test -f 'man/yank.1'
then
${echo} "x - SKIPPING man/yank.1 (file already exists)"

else
${echo} "x - extracting man/yank.1 (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'man/yank.1' &&
X.\" -*- mode: troff; coding: utf-8 -*-
X.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
X.\"
X.\" Standard preamble:
X.\" ========================================================================
X.de Sp \" Vertical space (when we can't use .PP)
X.if t .sp .5v
X.if n .sp
X..
X.de Vb \" Begin verbatim text
X.ft CW
X.nf
X.ne \\$1
X..
X.de Ve \" End verbatim text
X.ft R
X.fi
X..
X.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
X.ie n \{\
X.    ds C` ""
X.    ds C' ""
'br\}
X.el\{\
X.    ds C`
X.    ds C'
'br\}
X.\"
X.\" Escape single quotes in literal strings from groff's Unicode transform.
X.ie \n(.g .ds Aq \(aq
X.el       .ds Aq '
X.\"
X.\" If the F register is >0, we'll generate index entries on stderr for
X.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
X.\" entries marked with X<> in POD.  Of course, you'll have to process the
X.\" output yourself in some meaningful fashion.
X.\"
X.\" Avoid warning from groff about undefined register 'F'.
X.de IX
X..
X.nr rF 0
X.if \n(.g .if rF .nr rF 1
X.if (\n(rF:(\n(.g==0)) \{\
X.    if \nF \{\
X.        de IX
X.        tm Index:\\$1\t\\n%\t"\\$2"
X..
X.        if !\nF==2 \{\
X.            nr % 0
X.            nr F 2
X.        \}
X.    \}
X.\}
X.rr rF
X.\" ========================================================================
X.\"
X.IX Title "YANK 1"
X.TH YANK 1 2025-12-31 github.com/fjardon/unix-config "FJ Unix Config Commands"
X.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
X.\" way too many mistakes in technical documents.
X.if n .ad l
X.nh
X.SH NAME
yank \- Script converting input into OSC 5\-2 escape sequence
X.SH SYNOPSIS
X.IX Header "SYNOPSIS"
\&\fByank\fR \fB\-h\fR|\fB\-\-help\fR
X.PP
\&\fByank\fR [\fBOPTIONS\fR]
X.PP
echo "Text To Copy" | \fByank\fR
X.SH DESCRIPTION
X.IX Header "DESCRIPTION"
This tool converts standard input into \fBOSC 5\-2\fR escape sequence and outputs
it to a terminal. These escape sequences are interpreted by terminals to set
their \fBselection\fR buffer. For \fBXTerm\fR it means the \fBX11\fR copy/paste buffer.
X.PP
The script can used to provide seamless copy/paste capabilities between a host
and a remote session. For instance a user running \fBvim\fR through \fBtmux\fR on a
remote host connected by \fBssh\fR running on its \fBWindows\fR laptop.
X.PP
The output of the program should be directed to a terminal. In case no terminal
is specified, the script will use \fI/dev/tty\fR.
X.SH OPTIONS
X.IX Header "OPTIONS"
X.IP \fB\-h\fR|\fB\-\-help\fR 4
X.IX Item "-h|--help"
Print the usage, help and version information for this program and exit.
X.IP "\fB\-t\fR \fITERMINAL\fR|\fB\-\-terminal\fR=\fITERMINAL\fR" 4
X.IX Item "-t TERMINAL|--terminal=TERMINAL"
Sets the terminal used to output the OSC 5\-2 escape sequence. In case the
terminal is not specified, the default value is: \fI/dev/tty\fR.
X.IP \fB\-\-tmux\-tty\fR 4
X.IX Item "--tmux-tty"
Sets the terminal used to output the OSC 5\-2 escape sequence to the \fBtmux\fR pane
tty. In case the program is unable to find out \fBtmux\fR pane's tty, the value of
the \fB\-\-terminal\fR option is taken into account.
X.IP \fB\-l\fR=\fIINCEPTION\fR|\fB\-\-inception\-level\fR=\fIINCEPTION\fR 4
X.IX Item "-l=INCEPTION|--inception-level=INCEPTION"
Sets the \fBtmux\fR inception level. This is needed in case you connect to another
\&\fBtmux\fR session from within a \fBtmux\fR session. Default value is 0 unless the
\&\fBTMUX\fR environment variable is set, in which case the default value is 1.
X.SH LIMITATIONS
X.IX Header "LIMITATIONS"
No more than 74994 bytes of data can be transmitted through the OSC 5\-2 escape
sequence.
X.SH "ENVIRONMENT VARIABLES"
X.IX Header "ENVIRONMENT VARIABLES"
X.IP TMUX 4
X.IX Item "TMUX"
The \fBTMUX\fR environment variable is used to find out if we are running inside
a \fBtmux\fR pane.
X.SH "SEE ALSO"
X.IX Header "SEE ALSO"
\&\fBxterm\fR\|(1), \fBtmux\fR\|(1)
X.IP "\fIXTerm Control Sequences\fR" 4
X.IX Item "XTerm Control Sequences"
X.Vb 1
\&    https://invisible\-island.net/xterm/ctlseqs/ctlseqs.html#h2\-Operating\-System\-Commands
X.Ve
X.IP "\fIDevice Control String Sequences\fR" 4
X.IX Item "Device Control String Sequences"
X.Vb 1
\&    https://vt100.net/docs/vt510\-rm/chapter4.html
X.Ve
X.IP "\fITMux DCS Sequences\fR" 4
X.IX Item "TMux DCS Sequences"
X.Vb 1
\&    see tmux changelog
X.Ve
X.SH AUTHOR
X.IX Header "AUTHOR"
Frederic JARDON <frederic.jardon@gmail.com>
X.SH "COPYRIGHT AND LICENSE"
X.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2017 by Frederic JARDON <frederic.jardon@gmail.com>
X.PP
This program is free software; you can redistribute it and/or modify
it under the MIT license.
SHAR_EOF
  (set 20 26 02 15 11 19 16 'man/yank.1'
   eval "${shar_touch}") && \
  chmod 0760 'man/yank.1'
if test $? -ne 0
then ${echo} "restore of man/yank.1 failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'man/yank.1': 'MD5 check failed'
       ) << \SHAR_EOF
ba4a33fcd82f5d819769c44c0efb2308  man/yank.1
SHAR_EOF

else
test `LC_ALL=C wc -c < 'man/yank.1'` -ne 4606 && \
  ${echo} "restoration warning:  size of 'man/yank.1' is not 4606"
  fi
fi
if rm -fr ${lock_dir}
then ${echo} "x - removed lock directory ${lock_dir}."
else ${echo} "x - failed to remove lock directory ${lock_dir}."
     exit 1
fi
exit 0
SETUP_SHAR_EOF
/bin/sh setup.shar > /dev/null
# =============================================================================

# Make uudecode available if not present on system
if ! has_prog uudecode; then
    mv scripts/uudecode.pl uudecode
    chmod 0755 uudecode
    export PATH="${PWD}:${PATH}"
fi

# Prepare backups directory
DATE=$(date '+%Y%m%d')
HOUR=$(date '+%H%M%S')
BACKUPDIR="${PREFIX}/.backups/${DATE}/${HOUR}"
${INSTALL_P} -d "${BACKUPDIR}"

# Backup files
echo "shell ..."
if [ -e "${PREFIX}/.profile" ]; then
    cp -f "${PREFIX}/.profile" "${BACKUPDIR}"
fi
if [ -e "${PREFIX}/.bash_profile" ]; then
    cp -f "${PREFIX}/.bash_profile" "${BACKUPDIR}"
fi
if [ -e "${PREFIX}/.bashrc" ]; then
    cp -f "${PREFIX}/.bashrc" "${BACKUPDIR}"
fi
if [ ! -e "${PREFIX}/.path_dirs" ]; then
    cat <<DOT_PROFILE_PATHS_EOF > "${PREFIX}/.path_dirs"
# Directory path in this file are scanned by .bash_profile
# to setup the following variables:
#  - PATH
#  - LD_LIBRARY_PATH
#  - MANPATH
#  - INFOPATH
#  - PERL5LIB
#  - PKG_CONFIG_PATH

${PREFIX}/.local
${PREFIX}/.local/share/perl5
DOT_PROFILE_PATHS_EOF
fi
${INSTALL_R} dot/profile      "${PREFIX}/.profile"
${INSTALL_R} dot/bash_profile "${PREFIX}/.bash_profile"
${INSTALL_R} dot/bashrc       "${PREFIX}/.bashrc"

# .local setup
echo "local ..."
${INSTALL_X} -d "${PREFIX}/.local/bin"
${INSTALL_X} -d "${PREFIX}/.local/lib"
${INSTALL_X} -d "${PREFIX}/.local/opt"
${INSTALL_X} -d "${PREFIX}/.local/share"
${INSTALL_X} -d "${PREFIX}/.local/share/man/man1"
${INSTALL_X} -d "${PREFIX}/.local/var"
${INSTALL_X} -d "${PREFIX}/.local/var/lock"
${INSTALL_X} -d "${PREFIX}/.local/var/log"
${INSTALL_X} -d "${PREFIX}/.local/var/run"
${INSTALL_X} -d "${PREFIX}/.local/etc/cron"
${INSTALL_X} -d "${PREFIX}/.local/etc/profile.d"
${INSTALL_X} scripts/runcron "${PREFIX}/.local/bin"
PATH="${PATH}:${PREFIX}/.local/bin"
export PATH

# Cron setup
echo "cron ..."
if has_prog crontab; then
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/hourly"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/daily"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/daily-4"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/daily-8"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/daily-12"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/daily-16"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/daily-20"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/weekly"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/monthly"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/yearly"
    ${INSTALL_X} -d "${PREFIX}/.local/etc/cron/commands"
    touch "${PREFIX}/.local/etc/cron/environ.bash"

    crontab -l > "${BACKUPDIR}/crontab"
    tmpcrontab=$(mktemp)
    grep -v "${PREFIX}/.local/bin/runcron" "${BACKUPDIR}/crontab" \
         > "${tmpcrontab}"
    echo "0  * * * *" "${PREFIX}/.local/bin/runcron hourly"   >> "${tmpcrontab}"
    echo "0  0 * * *" "${PREFIX}/.local/bin/runcron daily"    >> "${tmpcrontab}"
    echo "0  4 * * *" "${PREFIX}/.local/bin/runcron daily-4"  >> "${tmpcrontab}"
    echo "0  8 * * *" "${PREFIX}/.local/bin/runcron daily-8"  >> "${tmpcrontab}"
    echo "0 12 * * *" "${PREFIX}/.local/bin/runcron daily-12" >> "${tmpcrontab}"
    echo "0 16 * * *" "${PREFIX}/.local/bin/runcron daily-16" >> "${tmpcrontab}"
    echo "0 20 * * *" "${PREFIX}/.local/bin/runcron daily-20" >> "${tmpcrontab}"
    echo "0  0 * * 0" "${PREFIX}/.local/bin/runcron weekly"   >> "${tmpcrontab}"
    echo "0  0 1 * *" "${PREFIX}/.local/bin/runcron monthly"  >> "${tmpcrontab}"
    echo "0  0 1 1 *" "${PREFIX}/.local/bin/runcron yearly"   >> "${tmpcrontab}"
    crontab "${tmpcrontab}"
    rm -f "${tmpcrontab}"
fi

# Cygwin
case "${os_name}" in
    CYGWIN*)
        echo "Cygwin ..."
        if [ -e "${PREFIX}/.XWinrc" ]; then
            cp -f "${PREFIX}/.XWinrc" "${BACKUPDIR}"
        fi
        ${INSTALL_R} dot/XWinrc         "${PREFIX}/.XWinrc"
        ${INSTALL_X} scripts/hyper-v    "${PREFIX}/.local/bin"
        ${INSTALL_R} man/hyper-v.1      "${PREFIX}/.local/share/man/man1"
        ${INSTALL_X} scripts/apt-cyg    "${PREFIX}/.local/bin"
        ${INSTALL_X} scripts/msvc-shell "${PREFIX}/.local/bin"
        ${INSTALL_R} man/msvc-shell.1   "${PREFIX}/.local/share/man/man1"
        ${INSTALL_X} scripts/bshell.bat "${PREFIX}/.local/bin"
        ;;
    MINGW*)
        ${INSTALL_X} scripts/msvc-shell "${PREFIX}/.local/bin"
        ${INSTALL_R} man/msvc-shell.1   "${PREFIX}/.local/share/man/man1"
        ${INSTALL_X} scripts/bshell.bat "${PREFIX}/.local/bin"
        ;;
esac

# Python
echo "Python ..."
echo " - checking if cppman is installed"
if ! has_prog cppman; then
    if has_prog pip3; then
        echo " - installing cppman plugin with pip3"
        [ 'yes' != "${DRYRUN}" ] && pip3 install --user cppman > install.log 2>&1
    fi
fi

# Ruby
if [ -e "${PREFIX}/.gemrc" ]; then
    cp -f "${PREFIX}/.gemrc" "${BACKUPDIR}"
fi
${INSTALL_R} dot/gemrc "${PREFIX}/.gemrc"

# vim
echo "vim ..."
if [ -e "${PREFIX}/.vimrc" ]; then
    cp -f "${PREFIX}/.vimrc" "${BACKUPDIR}"
fi
${INSTALL_R} dot/vimrc "${PREFIX}/.vimrc"

# tmux
echo "tmux ..."
if [ -e "${PREFIX}/.tmux.conf" ]; then
    cp -f "${PREFIX}/.tmux.conf" "${BACKUPDIR}"
fi
${INSTALL_R} dot/tmux.conf "${PREFIX}/.tmux.conf"
${INSTALL_X} scripts/yank  "${PREFIX}/.local/bin"
${INSTALL_R} man/yank.1    "${PREFIX}/.local/share/man/man1"

echo "terminfo ..."
if has_prog tic; then
    has_tmux256_terminfo=""
    if [ -e /lib/terminfo/t/tmux-256color ]; then
        has_tmux256_terminfo="y"
    fi
    if [ -e /usr/share/terminfo/t/tmux-256color ]; then
        has_tmux256_terminfo="y"
    fi
    if [ -e "${PREFIX}/.terminfo/t/tmux-256color" ]; then
        has_tmux256_terminfo="y"
    fi
    if [ -z "${has_tmux256_terminfo}" ]; then
        mkdir -p "${PREFIX}/.terminfo"
        tic -o "${PREFIX}/.terminfo" data/tmux-256color.tinfo
    fi
fi

# Perl
echo "Perl ..."
if [ ! -e "${PREFIX}/.local/share/perl5" ]; then
    perl_local_lib=local-lib-2.000029
    curl -s -O "http://www.cpan.org/authors/id/H/HA/HAARG/${perl_local_lib}.tar.gz"
    tar zxf "${perl_local_lib}.tar.gz"
    cd  "${perl_local_lib}"
    perl Makefile.PL "--bootstrap=${PREFIX}/.local/share/perl5" > install.log 2>&1
    make test > install.log 2>&1 && make install > install.log 2>&1
    cd ..
    perl "-I${PREFIX}/.local/share/perl5/lib/perl5" "-Mlocal::lib=${PREFIX}/.local/share/perl5" \
        > "${PREFIX}/.local/etc/profile.d/perl5.sh"
    source "${PREFIX}/.local/etc/profile.d/perl5.sh"
fi

# Scripts
${INSTALL_X} scripts/codefmt       "${PREFIX}/.local/bin"
${INSTALL_R} man/codefmt.1         "${PREFIX}/.local/share/man/man1"
${INSTALL_X} scripts/codemv        "${PREFIX}/.local/bin"
${INSTALL_R} man/codemv.1          "${PREFIX}/.local/share/man/man1"
${INSTALL_X} scripts/plgen         "${PREFIX}/.local/bin"
${INSTALL_R} man/plgen.1           "${PREFIX}/.local/share/man/man1"
${INSTALL_X} scripts/sixel2tmux    "${PREFIX}/.local/bin"
${INSTALL_R} man/sixel2tmux.1      "${PREFIX}/.local/share/man/man1"
${INSTALL_X} scripts/byzanz-helper "${PREFIX}/.local/bin"
${INSTALL_R} man/byzanz-helper.1   "${PREFIX}/.local/share/man/man1"
${INSTALL_X} scripts/ffmpeg-helper "${PREFIX}/.local/bin"
${INSTALL_R} man/ffmpeg-helper.1   "${PREFIX}/.local/share/man/man1"

# Autoconf cache
echo "Autoconf cache ..."
if [ ! -e "${PREFIX}/.local/etc/config.site" ]; then
    cp data/config.site "${PREFIX}/.local/etc/config.site"
fi

# GDB pretty printers
echo "GDB pretty-printers for libstdc++"
if [ ! -e "${PREFIX}/.local/share/gdb" ]; then
    mkdir -p "${PREFIX}/.local/share/gdb"
    cp -r libstdc++-v3/python "${PREFIX}/.local/share/gdb/"
    if [ -e "${PREFIX}/.gdbinit" ]; then
        cp -f "${PREFIX}/.gdbinit" "${BACKUPDIR}"
    fi
    cp -f dot/gdbinit "${PREFIX}/.gdbinit"
fi

# Gnulib
echo "Gnulib ..."
if ! has_prog gnulib-tool; then
    if [ ! -e "${PREFIX}/.local/share/gnulib" ]; then
        git clone git://git.savannah.gnu.org/gnulib.git "${PREFIX}/.local/share/gnulib" > install.log 2>&1
    fi
    ln -s "${PREFIX}/.local/share/gnulib/gnulib-tool"    "${PREFIX}/.local/bin/gnulib-tool"
    ln -s "${PREFIX}/.local/share/gnulib/gnulib-tool.py" "${PREFIX}/.local/bin/gnulib-tool.py"
fi

# TeX
echo "TeX ..."
if has_prog kpsewhich; then
    texmf_home=$(kpsewhich -var-value TEXMFHOME)
    if [ ! -e "${texmf_home}/tex/latex/createspace" ]; then
        mkdir -p "${texmf_home}/tex/latex/"
        git clone https://github.com/aginiewicz/createspace.git "${texmf_home}/tex/latex/createspace" > install.log 2>&1
    fi
fi

# # Asciidoctor
# echo "Asciidoctor ..."
# if has_prog gem && has_prog bison && has_prog flex && has_prog cmake; then
#     gem install --user-install pygments.rb
#     gem install --user-install asciimath
#     gem install --user-install asciidoctor-pdf
#     gem install --user-install mathematical
#     gem install --user-install asciidoctor-mathematical
#     gem install --user-install asciidoctor-diagram
# fi


echo "Finished installing in '${PREFIX}'. Backup created in '${BACKUPDIR}'."
